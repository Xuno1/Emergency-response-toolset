<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>5.5. Import Hex Dump</title><link rel="stylesheet" type="text/css" href="ws.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="Wireshark User’s Guide"><link rel="up" href="ChapterIO.html" title="Chapter 5. File Input, Output, And Printing"><link rel="prev" href="ChIOMergeSection.html" title="5.4. Merging Capture Files"><link rel="next" href="ChIOFileSetSection.html" title="5.6. File Sets"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">5.5. Import Hex Dump</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ChIOMergeSection.html">Prev</a> </td><th width="60%" align="center">Chapter 5. File Input, Output, And Printing</th><td width="20%" align="right"> <a accesskey="n" href="ChIOFileSetSection.html">Next</a></td></tr></table><hr></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ChIOImportSection"></a>5.5. Import Hex Dump</h2></div></div></div>

<p>Wireshark can read in a hex dump and write the data described into a
temporary libpcap capture file. It can read hex dumps with multiple packets in
them, and build a capture file of multiple packets. It is also capable of
generating dummy Ethernet, IP and UDP, TCP, or SCTP headers, in order to build
fully processable packet dumps from hexdumps of application-level data only.
Alternatively, a Dummy PDU header can be added to specify a dissector the data
should be passed to initially.</p>
<p>Two methods for converting the input are supported:</p>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_standard_ascii_hexdumps"></a>5.5.1. Standard ASCII Hexdumps</h3></div></div></div>

<p>Wireshark understands a hexdump of the form generated by <code class="literal">od -Ax -tx1 -v</code>.
In other words, each byte is individually displayed, with spaces separating
the bytes from each other.  Hex digits can be upper or lowercase.</p>
<p>In normal operation, each line must begin with an offset describing the
position in the packet, followed a colon, space, or tab separating it from
the bytes.  There is no limit on the width or number of bytes per line, but
lines with only hex bytes without a leading offset are ignored (i.e.,
line breaks should not be inserted in long lines that wrap.) Offsets are more
than two digits; they are in hex by default, but can also be in octal or
decimal.  Each packet must begin with offset zero, and an offset
zero indicates the beginning of a new packet.  Offset values must be correct;
an unexpected value causes the current packet to be aborted and the next
packet start awaited.  There is also a single packet mode with no offsets.</p>
<p>Packets may be preceded by a direction indicator ('I' or 'O') and/or a
timestamp if indicated.  If both are present, the direction indicator precedes
the timestamp.  The format of the timestamps must be specified.  If no timestamp
is parsed, in the case of the first packet the current system time is used,
while subsequent packets are written with timestamps one microsecond later than
that of the previous packet.</p>
<p>Other text in the input data is ignored. Any text before the offset is
ignored, including email forwarding characters '&gt;'. Any text on a line
after the bytes is ignored, e.g., an ASCII character dump (but see <span class="strong"><strong>-a</strong></span> to
ensure that hex digits in the character dump are ignored).  Any line where
the first non-whitespace character is a '#' will be ignored as a comment.
Any lines of text between the bytestring lines are considered preamble;
the beginning of the preamble is scanned for the direction indicator and
timestamp as mentioned above and otherwise ignored.</p>
<p>Any line beginning with #TEXT2PCAP is a directive and options
can be inserted after this command to be processed by Wireshark.
Currently there are no directives implemented; in the future, these may
be used to give more fine-grained control on the dump and the way it
should be processed e.g., timestamps, encapsulation type etc.</p>
<p>In general, short of these restrictions, Wireshark is pretty liberal
about reading in hexdumps and has been tested with a variety of
mangled outputs (including being forwarded through email multiple
times, with limited line wrap etc.)</p>
<p>Here is a sample dump that can be imported, including optional
directional indicator and timestamp:</p>
<pre class="screen">I 2019-05-14T19:04:57Z
000000 00 e0 1e a7 05 6f 00 10 ........
000008 5a a0 b9 12 08 00 46 00 ........
000010 03 68 00 00 00 00 0a 2e ........
000018 ee 33 0f 19 08 7f 0f 19 ........
000020 03 80 94 04 00 00 10 01 ........
000028 16 a2 0a 00 03 50 00 0c ........
000030 01 01 0f 19 03 80 11 01 ........</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_regular_text_dumps"></a>5.5.2. Regular Text Dumps</h3></div></div></div>

<p>Wireshark is also capable of scanning the input using a custom Perl regular
expression as specified by GLib’s <a class="ulink" href="https://developer-old.gnome.org/glib/stable/glib-regex-syntax.html" target="_top">GRegex here</a>.
Using a regex capturing a single packet in the given file
Wireshark will search the given file from start to the second to last character
(the last character has to be <code class="literal">\n</code> and is ignored)
for non-overlapping (and non-empty) strings matching the given regex and then
identify the fields to import using named capturing subgroups. Using provided
format information for each field they are then decoded and translated into a
standard libpcap file retaining packet order.</p>
<p>Note that each named capturing subgroup has to match <span class="emphasis"><em>exactly</em></span> once a packet,
but they may be present multiple times in the regex.</p>
<p>For example, the following dump:</p>
<pre class="screen">&gt; 0:00:00.265620 a130368b000000080060
&gt; 0:00:00.280836 a1216c8b00000000000089086b0b82020407
&lt; 0:00:00.295459 a2010800000000000000000800000000
&gt; 0:00:00.296982 a1303c8b00000008007088286b0bc1ffcbf0f9ff
&gt; 0:00:00.305644 a121718b0000000000008ba86a0b8008
&lt; 0:00:00.319061 a2010900000000000000001000600000
&gt; 0:00:00.330937 a130428b00000008007589186b0bb9ffd9f0fdfa3eb4295e99f3aaffd2f005
&gt; 0:00:00.356037 a121788b0000000000008a18</pre>
<p>could be imported using these settings:</p>
<pre class="screen">regex: ^(?&lt;dir&gt;[&lt;&gt;])\s(?&lt;time&gt;\d+:\d\d:\d\d.\d+)\s(?&lt;data&gt;[0-9a-fA-F]+)$
timestamp: %H:%M:%S.%f
dir: in: &lt;   out: &gt;
encoding: HEX</pre>
<p>Caution has to be applied when discarding the anchors <code class="literal">^</code> and <code class="literal">$</code>, as the input
is searched, not parsed, meaning even most incorrect regexes will produce valid
looking results when not anchored (however, anchors are not guaranteed to prevent
this). It is generally recommended to sanity check any files created using
this conversion.</p>
<p>Supported fields:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<p class="simpara">data: Actual captured frame data</p>
<p class="simpara">The only mandatory field. This should match the encoded binary data captured and
is used as the actual frame data to import.</p>
</li><li class="listitem">
<p class="simpara">time: timestamp for the packet</p>
<p class="simpara">The captured field will be parsed according to the given timestamp format into a
timestamp.</p>
<p class="simpara">If no timestamp is present an arbitrary counter will count up seconds and
nanoseconds by one each packet.</p>
</li><li class="listitem">
<p class="simpara">dir: the direction the packet was sent over the wire</p>
<p class="simpara">The captured field is expected to be one character in length, any remaining
characters are ignored (e.g., given "Input" only the 'I' is looked at). This
character is compared to lists of characters corresponding to inbound and
outbound and the packet is assigned the corresponding direction.
If neither list yields a match, the direction is set to unknown.</p>
<p class="simpara">If this field is not specified the entire file has no directional information.</p>
</li><li class="listitem">
<p class="simpara">seqno: an ID for this packet</p>
<p class="simpara">Each packet can be assigned an arbitrary ID that can used as field by Wireshark.
This field is assumed to be a positive integer base 10. This field can e.g.
be used to reorder out of order captures after the import.</p>
<p class="simpara">If this field is not given, no IDs will be present in the resulting file.</p>
</li></ul></div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_the_import_from_hex_dump_dialog_box"></a>5.5.3. The “Import From Hex Dump” Dialog Box</h3></div></div></div>

<p>This dialog box lets you select a text file, containing a hex dump of packet
data, to be imported and set import parameters.</p>
<div class="figure"><a name="ChIOFileImportDialog"></a><p class="title"><b>Figure 5.7. The “Import from Hex Dump” dialog in Hex Dump mode</b></p><div class="figure-contents">

<div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="60%"><tr><td><img src="images/ws-file-import.png" width="100%" alt="ws file import"></td></tr></table></div>
</div></div><br class="figure-break">
<p>Specific controls of this import dialog are split in three sections:</p>
<div class="variablelist"><dl class="variablelist"><dt><span class="term">File Source</span></dt><dd>
Determine which input file has to be imported
</dd><dt><span class="term">Input Format</span></dt><dd>
Determine how the input file has to be interpreted.
</dd><dt><span class="term">Encapsulation</span></dt><dd>
Determine how the data is to be encapsulated.
</dd></dl></div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_file_source"></a>5.5.4. File source</h3></div></div></div>

<div class="variablelist"><dl class="variablelist"><dt><span class="term">Filename / Browse</span></dt><dd>
Enter the name of the text file to import. You can use <span class="emphasis"><em>Browse</em></span> to browse for a
file.
</dd></dl></div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_input_format"></a>5.5.5. Input Format</h3></div></div></div>

<p>This section is split in the two alternatives for input conversion, accessible in
the two Tabs "Hex Dump" and "Regular Expression"</p>
<p>In addition to the conversion mode specific inputs, there are also common
parameters, currently only the timestamp format.</p>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_the_hex_dump_tab"></a>5.5.5.1. The Hex Dump tab</h4></div></div></div>

<div class="variablelist"><dl class="variablelist"><dt><span class="term">Offsets</span></dt><dd>
Select the radix of the offsets given in the text file to import. This is
usually hexadecimal, but decimal and octal are also supported. Select <span class="emphasis"><em>None</em></span>
when only the bytes are present. These will be imported as a single packet.
</dd><dt><span class="term">Direction indication</span></dt><dd>
Tick this box if the text file to import has direction indicators before each
frame. These are on a separate line before each frame and start with either
<span class="emphasis"><em>I</em></span> or <span class="emphasis"><em>i</em></span> for input and <span class="emphasis"><em>O</em></span> or <span class="emphasis"><em>o</em></span> for output.
</dd></dl></div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_the_regular_expression_tab"></a>5.5.5.2. The Regular Expression tab</h4></div></div></div>

<div class="figure"><a name="idm1585936192"></a><p class="title"><b>Figure 5.8. The "Regular Expression" tab inside the "Import from Hex Dump” dialog.</b></p><div class="figure-contents">

<div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="60%"><tr><td><img src="images/ws-file-import-regex.png" width="100%" alt="ws file import regex"></td></tr></table></div>
</div></div><br class="figure-break">
<div class="variablelist"><dl class="variablelist"><dt><span class="term">Packet format regular expression</span></dt><dd>
This is the regex used for searching packets and metadata inside the input file.
Named capturing subgroups are used to find the individual fields. Anchors <code class="literal">^</code> and
<code class="literal">$</code> are set to match directly before and after newlines <code class="literal">\n</code> or <code class="literal">\r\n</code>. See
<a class="ulink" href="https://developer-old.gnome.org/glib/stable/glib-regex-syntax.html" target="_top">GRegex</a> for a full
documentation.
</dd><dt><span class="term">Data encoding</span></dt><dd>
<p class="simpara">The Encoding used for the binary data. Supported encodings are plain-hexadecimal,
-octal, -binary and base64. Plain here means no additional
characters are present in the data field beyond whitespaces, which are ignored.
Any unexpected characters abort the import process.</p>
<p class="simpara">Ignored whitespaces are <code class="literal">\r</code>, <code class="literal">\n</code>, <code class="literal">\t</code>, <code class="literal">\v</code>, ` ` and only for hex <code class="literal">:</code>, only
for base64 <code class="literal">=</code>.</p>
<p class="simpara">Any incomplete bytes at the field’s end are assumed to be padding to fill the
last complete byte. These bits should be zero, however, this is not checked.</p>
</dd><dt><span class="term">Direction indication</span></dt><dd>
The lists of characters indicating incoming vs. outgoing packets. These fields
are only available when the regex contains a <code class="literal">(?&lt;dir&gt;…​)</code> group.
</dd></dl></div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_common_items"></a>5.5.5.3. Common items</h4></div></div></div>

<div class="variablelist"><dl class="variablelist"><dt><span class="term">Timestamp Format</span></dt><dd>
<p class="simpara">This is the format specifier used to parse the timestamps in the text file to
import. It uses the same format as <code class="literal">strptime(3)</code> with the addition of <code class="literal">%f</code> for
zero padded fractions of seconds. The precision of <code class="literal">%f</code> is determined from its
length. The most common fields are <code class="literal">%H</code>, <code class="literal">%M</code> and <code class="literal">%S</code> for hours, minutes and
seconds. The straightforward HH:MM:SS format is covered by %T. For a full
definition of the syntax look for <code class="literal">strptime(3)</code>,</p>
<p class="simpara">In Regex mode this field is only available when a <code class="literal">(?&lt;time&gt;…​)</code> group is present.</p>
<p class="simpara">In Hex Dump mode if there are no timestamps in the text file to import, leave this
field empty and timestamps will be generated based on the time of import.</p>
</dd></dl></div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_encapsulation"></a>5.5.6. Encapsulation</h3></div></div></div>

<div class="variablelist"><dl class="variablelist"><dt><span class="term">Encapsulation type</span></dt><dd>
Here you can select which type of frames you are importing. This all depends on
from what type of medium the dump to import was taken. It lists all types that
Wireshark understands, so as to pass the capture file contents to the right
dissector.
</dd><dt><span class="term">Dummy header</span></dt><dd>
When Ethernet encapsulation is selected you have to option to prepend dummy
headers to the frames to import. These headers can provide artificial Ethernet,
IP, UDP, TCP or SCTP headers or SCTP data chunks. When selecting a type of
dummy header, the applicable entries are enabled, others are greyed out and
default values are used.
When the <span class="emphasis"><em>Wireshark Upper PDU export</em></span> encapsulation is selected the option
<span class="emphasis"><em>ExportPDU</em></span> becomes available. This allows you to select the name of the
dissector these frames are to be directed to.
</dd><dt><span class="term">Maximum frame length</span></dt><dd>
You may not be interested in the full frames from the text file, just the first
part. Here you can define how much data from the start of the frame you want to
import. If you leave this open the maximum is set to 256kiB.
</dd></dl></div>
<p>Once all input and import parameters are setup click <span class="guibutton">Import</span> to start the
import. If your current data wasn’t saved before you will be asked to save it
first.</p>
<p>If the import button doesn’t unlock, make sure all encapsulation parameters are
in the expected range and all unlocked fields are populated when using regex mode
(the placeholder text is not used as default).</p>
<p>When completed there will be a new capture file loaded with the frames imported
from the text file.</p>
</div>
</div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ChIOMergeSection.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ChapterIO.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ChIOFileSetSection.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">5.4. Merging Capture Files </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 5.6. File Sets</td></tr></table></div></body></html>
