<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>12.3. MATE Manual</title><link rel="stylesheet" type="text/css" href="ws.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="Wireshark User’s Guide"><link rel="up" href="ChMate.html" title="Chapter 12. MATE"><link rel="prev" href="ChMateGettingStarted.html" title="12.2. Getting Started"><link rel="next" href="ChMateConfigurationTutorial.html" title="12.4. MATE’s configuration tutorial"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">12.3. MATE Manual</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ChMateGettingStarted.html">Prev</a> </td><th width="60%" align="center">Chapter 12. MATE</th><td width="20%" align="right"> <a accesskey="n" href="ChMateConfigurationTutorial.html">Next</a></td></tr></table><hr></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ChMateManual"></a>12.3. MATE Manual</h2></div></div></div>

<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_introduction"></a>12.3.1. Introduction</h3></div></div></div>

<p>MATE creates a filterable tree based on information contained in frames that
share some relationship with information obtained from other frames. The way
these relationships are made is described in a configuration file. The
configuration file tells MATE what makes a PDU and how to relate it to other
PDUs.</p>
<p>MATE analyzes each frame to extract relevant information from the "protocol"
tree of that frame. The extracted information is contained in MATE PDUs;
these contain a list of relevant attributes taken from the tree. From now on, I
will use the term "PDU" to refer to the objects created by MATE containing the
relevant information extracted from the frame; I’ll use "frame" to refer to the
"raw" information extracted by the various dissectors that pre-analyzed the frame.</p>
<p>For every PDU, MATE checks if it belongs to an existing "Group of PDUs" (Gop).
If it does, it assigns the PDU to that Gop and moves any new relevant attributes
to the Gop’s attribute list. How and when do PDUs belong to Gops is described
in the configuration file as well.</p>
<p>Every time a Gop is assigned a new PDU, MATE will check if it matches the
conditions to make it belong to a "Group of Groups" (Gog). Naturally the
conditions that make a Gop belong to a Gog are taken from the configuration
file as well.</p>
<p>Once MATE is done analyzing the frame it will be able to create a "protocol"
tree for each frame based on the PDUs, the Gops they belong to and naturally any
Gogs the former belongs to.</p>
<p>How to tell MATE what to extract, how to group it and then how to relate those
groups is made using AVPs and AVPLs.</p>
<p>Information in MATE is contained in Attribute/Value Pairs (AVPs). AVPs are made
of two strings: the name and the value. AVPs are used in the configuration and
there they have an operator as well. There are various ways AVPs can be matched
against each other using those operators.</p>
<p>AVPs are grouped into AVP Lists (AVPLs). PDUs, Gops and Gogs have an AVPL each.
Their AVPLs will be matched in various ways against others coming from the
configuration file.</p>
<p>MATE will be instructed how to extract AVPs from frames in order to create a PDU
with an AVPL. It will be instructed as well, how to match that AVPL against the
AVPLs of other similar PDUs in order to relate them. In MATE the relationship
between PDUs is a Gop, it has an AVPL as well. MATE will be configured with other
AVPLs to operate against the Gop’s AVPL to relate Gops together into Gogs.</p>
<p>A good understanding on how AVPs and AVPLs work is fundamental to understand how
MATE works.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="AVP"></a>12.3.2. Attribute Value Pairs</h3></div></div></div>

<p>Information used by MATE to relate different frames is contained in Attribute/
Value Pairs (AVPs). AVPs are made of two strings - the name and the value. When
AVPs are used in the configuration, an operator is defined as well. There are
various ways AVPs can be matched against each other using those operators.</p>
<pre class="screen">  avp_name="avp's value"
  another_name= "1234 is the value"</pre>
<p>The name is a string used to refer to a "kind" of an AVP. Two AVPs won’t match
unless their names are identical.</p>
<p>You should not use uppercase characters in names, or names that start with “.” or
“_”. Capitalized names are reserved for configuration parameters (we’ll call them
keywords); nothing forbids you from using capitalized strings for other things as
well but it probably would be confusing. I’ll avoid using capitalized words for
anything but the keywords in this document, the reference manual, the examples
and the base library. Names that start with a “.” would be very confusing as well
because in the old grammar, AVPL transformations use names starting with a “.” to
indicate they belong to the replacement AVPL.</p>
<p>The value is a string that is either set in the configuration (for configuration
AVPs) or by Wireshark while extracting interesting fields from a frame’s tree.
The values extracted from fields use the same representation as they do in filter
strings except that no quotes are used.</p>
<p>The name can contain only alphanumeric characters, "_", and ".". The name ends
with an operator.</p>
<p>The value will be dealt with as a string even if it is a number. If there are
any spaces in the value, the value must be between quotes "".</p>
<pre class="screen">   ip_addr=10.10.10.11,
   tcp_port=1234,
   binary_data=01:23:45:67:89:ab:cd:ef,
   parameter12=0x23aa,
   parameter_with_spaces="this value has spaces"</pre>
<p>The way two AVPs with the same name might match is described by the operator.
Remember two AVPs won’t match unless their names are identical. In MATE, match
operations are always made between the AVPs extracted from frames (called data
AVPs) and the configuration’s AVPs.</p>
<p>Currently defined MATE’s AVP match operators are:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<a class="link" href="ChMateReferenceManual.html#Equal" title="12.7.1.3.1. Equal AVP Operator">Equal</a> <span class="emphasis"><em>=</em></span> will match if the string given completely matches the data
AVP’s value string
</li><li class="listitem">
<a class="link" href="ChMateReferenceManual.html#NotEqual" title="12.7.1.3.2. Not equal AVP operator">Not Equal</a> <span class="emphasis"><em>!</em></span> will match only if the given value string is not equal to
the data AVP’s value string
</li><li class="listitem">
<a class="link" href="ChMateReferenceManual.html#OneOf" title='12.7.1.3.3. "One of" AVP operator'>One Of</a> <span class="emphasis"><em>{}</em></span> will match if one of the possible strings listed is equal to
the data AVP’s value string
</li><li class="listitem">
<a class="link" href="ChMateReferenceManual.html#StartsWith" title='12.7.1.3.4. "Starts with" AVP operator'>Starts With</a> <span class="emphasis"><em>^</em></span> will match if the string given matches the first
characters of the data AVP’s value string
</li><li class="listitem">
<a class="link" href="ChMateReferenceManual.html#EndsWith" title='12.7.1.3.5. "Ends with" operator'>Ends With</a> <span class="emphasis"><em>$</em></span> will match if the string given matches the last characters
of the data AVP’s value string
</li><li class="listitem">
<a class="link" href="ChMateReferenceManual.html#Contains" title="12.7.1.3.6. Contains operator">Contains</a> <span class="emphasis"><em>~</em></span> will match if the string given matches any substring of the
data AVP’s value string
</li><li class="listitem">
<a class="link" href="ChMateReferenceManual.html#LowerThan" title='12.7.1.3.7. "Lower than" operator'>Lower Than</a> <span class="emphasis"><em>&lt;</em></span> will match if the data AVP’s value string is semantically
lower than the string given
</li><li class="listitem">
<a class="link" href="ChMateReferenceManual.html#HigherThan" title='12.7.1.3.8. "Higher than" operator'>Higher Than</a> <span class="emphasis"><em>&gt;</em></span> will match if the data AVP’s value string is semantically
higher than the string given
</li><li class="listitem">
<a class="link" href="ChMateReferenceManual.html#Exists" title="12.7.1.3.9. Exists operator">Exists</a> <span class="emphasis"><em>?</em></span> (the ? can be omitted) will match as far as a data AVP of the
given name exists
</li></ul></div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_avp_lists"></a>12.3.3. AVP lists</h3></div></div></div>

<p>An AVPL is a set of diverse AVPs that can be matched against other AVPLs. Every
PDU, Gop and Gog has an AVPL that contains the information regarding it. The
rules that MATE uses to group Pdus and Gops are AVPL operations.</p>
<p>There will never be two identical AVPs in a given AVPL. However, we can have
more than one AVP with the same name in an AVPL as long as their values are
different.</p>
<p>Some AVPL examples:</p>
<pre class="screen">  ( addr=10.20.30.40, addr=192.168.0.1, tcp_port=21, tcp_port=32534, user_cmd=PORT, data_port=12344, data_addr=192.168.0.1 )
  ( addr=10.20.30.40, addr=192.168.0.1, channel_id=22:23, message_type=Setup, calling_number=1244556673 )
  ( addr=10.20.30.40, addr=192.168.0.1, ses_id=01:23:45:67:89:ab:cd:ef )
  ( user_id=pippo, calling_number=1244556673, assigned_ip=10.23.22.123 )</pre>
<p>In MATE there are two types of AVPLs:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
data AVPLs that contain information extracted from frames.
</li><li class="listitem">
operation AVPLs that come from the configuration and are used to tell MATE how
to relate items based on their data AVPLs.
</li></ul></div>
<p>Data AVPLs can be operated against operation AVPLs in various ways:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<a class="link" href="ChMateReferenceManual.html#Loose" title="12.7.2.1.1. Loose Match">Loose Match</a>: Will match if at least one of the AVPs of each AVPL
match. If it matches it will return an AVPL containing all AVPs from the operand
AVPL that did match the operator’s AVPs.
</li><li class="listitem">
<a class="link" href="ChMateReferenceManual.html#Every" title="12.7.2.1.2. Every Match">"Every" Match</a>: Will match if none of the AVPs of the operator AVPL
fails to match a present AVP in the operand AVPL, even if not all of the
operator’s AVPs have a match. If it matches it will return an AVPL containing
all AVPs from the operand AVPL that did match one AVP in the operator AVPL.
</li><li class="listitem">
<a class="link" href="ChMateReferenceManual.html#Strict" title="12.7.2.1.3. Strict Match">Strict Match</a>: Will match if and only if every one of the operator’s
AVPs have at least one match in the operand AVPL. If it matches it will return
an AVPL containing the AVPs from the operand that matched.
</li><li class="listitem">
There’s also a <a class="link" href="ChMateReferenceManual.html#Merge" title="12.7.2.1.4. AVPL Merge">Merge</a> operation that is to be performed between AVPLs
where all the AVPs that don’t exist in the operand AVPL but exist in the operand
will be added to the operand AVPL.
</li><li class="listitem">
Other than that, there are <a class="link" href="ChMateReferenceManual.html#Transform" title="12.7.2.1.5. Transforms">Transformations</a> - a combination
of a match AVPL and an AVPL to merge.
</li></ul></div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_mate_analysis"></a>12.3.4. MATE Analysis</h3></div></div></div>

<p>MATE’s analysis of a frame is performed in three phases:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
In the first phase, MATE attempts to extract a MATE Pdu from the frame’s
protocol tree. MATE will create a Pdu if MATE’s config has a <span class="emphasis"><em>Pdu</em></span> declaration
whose <span class="emphasis"><em>Proto</em></span> is contained in the frame.
</li><li class="listitem">
In the second phase, if a Pdu has been extracted from the frame, MATE will try
to group it to other Pdus into a Gop (Group of Pdus) by matching the key
criteria given by a <span class="emphasis"><em>Gop</em></span> declaration. If there is no Gop yet with the key
criteria for the Pdu, MATE will try to create a new Gop for it if it matches the
<span class="emphasis"><em>Start</em></span> criteria given in the Gop declaration.
</li><li class="listitem">
In the third phase, if there’s a Gop for the Pdu, MATE will try to group this
Gop with other Gops into a Gog (Group of Groups) using the criteria given by the
<span class="emphasis"><em>Member</em></span> criteria of a Gog declaration.
</li></ul></div>
<div class="informalfigure">
<div class="mediaobject"><img src="images/ws-mate-analysis.png" alt="ws mate analysis"></div>
</div>
<p>The extraction and matching logic comes from MATE’s configuration; MATE’s
configuration file is declared by the <span class="emphasis"><em>mate.config</em></span> preference. By default it is
an empty string which means: do not configure MATE.</p>
<p>The config file tells MATE what to look for in frames; How to make PDUs out of
it; How will PDUs be related to other similar PDUs into Gops; And how Gops
relate into Gogs.</p>
<p>The MATE configuration file is a list of declarations. There are 4 types of
declarations: <span class="emphasis"><em>Transform</em></span>, <span class="emphasis"><em>Pdu</em></span>, <span class="emphasis"><em>Gop</em></span> and <span class="emphasis"><em>Gog</em></span>.</p>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_mates_pdus"></a>12.3.4.1. Mate’s PDU’s</h4></div></div></div>

<p>MATE will look in the tree of every frame to see if there is useful data to
extract, and if there is, it will create one or more PDU objects containing the
useful information.</p>
<p>The first part of MATE’s analysis is the "PDU extraction"; there are various
"Actions" that are used to instruct MATE what has to be extracted from the
current frame’s tree into MATE’s PDUs.</p>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_pdu_data_extraction"></a>12.3.4.1.1. PDU data extraction</h5></div></div></div>

<p>MATE will make a Pdu for each different proto field of Proto type present in the
frame. MATE will fetch from the field’s tree those fields that are defined in
the <a class="xref" href="Config.html#Pdu" title="12.8.1. Pdsu’s configuration actions">Section 12.8.1, “Pdsu’s configuration actions”</a> declaration whose initial offset in the frame is within the
boundaries of the current Proto and those of the given Transport and Payload
statements.</p>
<pre class="screen">Pdu dns_pdu Proto dns Transport ip {
    Extract addr From ip.addr;
    Extract dns_id From dns.id;
    Extract dns_resp From dns.flags.response;
};</pre>
<p>MATE will make a Pdu for each different proto field of Proto type present in the
frame. MATE will fetch from the field’s tree those fields that are defined in
the <a class="xref" href="Config.html#Pdu" title="12.8.1. Pdsu’s configuration actions">Section 12.8.1, “Pdsu’s configuration actions”</a> AVPL whose initial offset in the frame is within the boundaries of
the current Proto and those of the various assigned Transports.</p>
<div class="informalfigure">
<div class="mediaobject"><img src="images/ws-mate-dns_pane.png" alt="ws mate dns pane"></div>
</div>
<p>Once MATE has found a <span class="emphasis"><em>Proto</em></span> field for which to create a Pdu from the frame it
will move backwards in the frame looking for the respective <span class="emphasis"><em>Transport</em></span> fields.
After that it will create AVPs named as each of those given in the rest of the
AVPL for every instance of the fields declared as its values.</p>
<div class="informalfigure">
<div class="mediaobject"><img src="images/ws-mate-dns_pdu.png" alt="ws mate dns pdu"></div>
</div>
<p>Sometimes we need information from more than one <span class="emphasis"><em>Transport</em></span> protocol. In that
case MATE will check the frame looking backwards to look for the various
<span class="emphasis"><em>Transport</em></span> protocols in the given stack. MATE will choose only the closest
transport boundary per "protocol" in the frame.</p>
<p>This way we’ll have all Pdus for every <span class="emphasis"><em>Proto</em></span> that appears in a frame match its
relative transports.</p>
<pre class="screen">Pdu isup_pdu Proto isup Transport mtp3/ip {
        Extract m3pc From mtp3.dpc;
        Extract m3pc From mtp3.opc;
        Extract cic From isup.cic;
        Extract addr From ip.addr;
        Extract isup_msg From isup.message_type;
};</pre>
<div class="informalfigure">
<div class="mediaobject"><img src="images/ws-mate-isup_over_mtp3_over_ip.png" alt="ws mate isup over mtp3 over ip"></div>
</div>
<p>This allows to assign the right <span class="emphasis"><em>Transport</em></span> to the Pdu avoiding duplicate
transport protocol entries (in case of tunneled ip over ip for example).</p>
<pre class="screen">Pdu ftp_pdu Proto ftp Transport tcp/ip {
        Extract addr From ip.addr;
        Extract port From tcp.port;
        Extract ftp_cmd From ftp.command;
};</pre>
<div class="informalfigure">
<div class="mediaobject"><img src="images/ws-mate-ftp_over_gre.png" alt="ws mate ftp over gre"></div>
</div>
<p>Other than the mandatory <span class="emphasis"><em>Transport</em></span> there is also an optional <span class="emphasis"><em>Payload</em></span>
statement, which works pretty much as <span class="emphasis"><em>Transport</em></span> but refers to elements after
the <span class="emphasis"><em>Proto</em></span>'s range. It is useful in those cases where the payload protocol
might not appear in a Pdu but nevertheless the Pdu belongs to the same category.</p>
<pre class="screen">Pdu mmse_over_http_pdu Proto http Transport tcp/ip {

        Payload mmse;

        Extract addr From ip.addr;
        Extract port From tcp.port;
        Extract method From http.request.method;
        Extract content From http.content_type;
        Extract http_rq From http.request;
        Extract resp From http.response.code;
        Extract host From http.host;
        Extract trx From mmse.transaction_id;
        Extract msg_type From mmse.message_type;
        Extract notify_status From mmse.status;
        Extract send_status From mmse.response_status;
};</pre>
<div class="informalfigure">
<div class="mediaobject"><img src="images/ws-mate-mmse_over_http.png" alt="ws mate mmse over http"></div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_conditions_on_which_to_create_pdus"></a>12.3.4.1.2. Conditions on which to create PDUs</h5></div></div></div>

<p>There might be cases in which we won’t want MATE to create a PDU unless some of
its extracted attributes meet or do not meet some criteria. For that we use the
<span class="emphasis"><em>Criteria</em></span> statements of the <span class="emphasis"><em>Pdu</em></span> declarations.</p>
<pre class="screen">Pdu isup_pdu Proto isup Transport mtp3/ip {
    ...

   // MATE will create isup_pdu PDUs only when there is not a point code '1234'
   Criteria Reject Strict (m3pc=1234);
};

Pdu ftp_pdu Proto ftp Transport tcp/ip {
    ...

    // MATE will create ftp_pdu PDUs only when they go to port 21 of our ftp_server
    Criteria Accept Strict (addr=10.10.10.10, port=21);
};</pre>
<p>The <span class="emphasis"><em>Criteria</em></span> statement is given an action (<span class="emphasis"><em>Accept</em></span> or <span class="emphasis"><em>Reject</em></span>), a match mode
(<span class="emphasis"><em>Strict</em></span>, <span class="emphasis"><em>Loose</em></span> or <span class="emphasis"><em>Every</em></span>) and an AVPL against which to match the currently
extracted one.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_transforming_the_attributes_of_a_pdu"></a>12.3.4.1.3. Transforming the attributes of a PDU</h5></div></div></div>

<p>Once the fields have been extracted into the Pdu’s AVPL, MATE will apply any
declared transformation to it. The way transforms are applied and how they work
is described later on. However, it’s useful to know that once the AVPL for the
Pdu is created, it may be transformed before being analyzed. That way we can
massage the data to simplify the analysis.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_mates_pdu_tree"></a>12.3.4.1.4. MATE’s PDU tree</h5></div></div></div>

<p>Every successfully created Pdu will add a MATE tree to the frame dissection. If
the Pdu is not related to any Gop, the tree for the Pdu will contain just the
Pdu’s info, if it is assigned to a Gop, the tree will also contain the Gop items,
and the same applies for the Gog level.</p>
<pre class="screen">mate dns_pdu:1
    dns_pdu: 1
        dns_pdu time: 3.750000
        dns_pdu Attributes
            dns_resp: 0
            dns_id: 36012
            addr: 10.194.4.11
            addr: 10.194.24.35</pre>
<p>The Pdu’s tree contains some filterable fields</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<span class="emphasis"><em>mate.dns_pdu</em></span> will contain the number of the "dns_pdu" Pdu
</li><li class="listitem">
<span class="emphasis"><em>mate.dns_pdu.RelativeTime</em></span> will contain the time passed since the beginning
of the capture in seconds
</li><li class="listitem">
<p class="simpara">the tree will contain the various attributes of the Pdu as well, these will
all be strings (to be used in filters as "10.0.0.1", not as 10.0.0.1)</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">
mate.dns_pdu.dns_resp
</li><li class="listitem">
mate.dns_pdu.dns_id
</li><li class="listitem">
mate.dns_pdu.addr
</li></ul></div>
</li></ul></div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_grouping_pdus_together_gop"></a>12.3.4.2. Grouping Pdus together (Gop)</h4></div></div></div>

<p>Once MATE has created the Pdus it passes to the Pdu analysis phase. During the
PDU analysis phase MATE will try to group Pdus of the same type into 'Groups of
Pdus' (aka *Gop*s) and copy some AVPs from the Pdu’s AVPL to the Gop’s AVPL.</p>
<div class="informalfigure">
<div class="mediaobject"><img src="images/ws-mate-pdu_analysis.png" alt="ws mate pdu analysis"></div>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_what_can_belong_to_a_gop"></a>12.3.4.2.1. What can belong to a Gop</h5></div></div></div>

<p>Given a Pdu, the first thing MATE will do is to check if there is any Gop
declaration in the configuration for the given Pdu type. If so, it will use its
<span class="emphasis"><em>Match</em></span> AVPL to match it against the Pdu’s AVPL; if they don’t match, the
analysis phase is done. If there is a match, the AVPL is the Gop’s candidate key
which will be used to search the Gop’s index for the Gop to which to assign
the current PDU. If there is no such Gop and this Pdu does not match the
<span class="emphasis"><em>Start</em></span> criteria of a Gop declaration for the Pdu type, the Pdu will remain
unassigned and only the analysis phase will be done.</p>
<pre class="screen">Gop ftp_ses On ftp_pdu Match (addr, addr, port, port);
Gop dns_req On dns_pdu Match (addr, addr, dns_id);
Gop isup_leg On isup_pdu Match (m3pc, m3pc, cic);</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_start_of_a_gop"></a>12.3.4.2.2. Start of a Gop</h5></div></div></div>

<p>If there was a match, the candidate key will be used to search the Gop’s index
to see if there is already a Gop matching the Gop’s key the same way. If there
is such a match in the Gops collection, and the PDU doesn’t match the <span class="emphasis"><em>Start</em></span>
AVPL for its kind, the PDU will be assigned to the matching Gop. If it is a
<span class="emphasis"><em>Start</em></span> match, MATE will check whether or not that Gop has been already
stopped. If the Gop has been stopped, a new Gop will be created and will replace
the old one in the Gop’s index.</p>
<pre class="screen">Gop ftp_ses On ftp_pdu Match (addr, addr, port, port) {
    Start (ftp_cmd=USER);
};

Gop dns_req On dns_pdu Match (addr, addr, dns_id) {
    Start (dns_resp=0);
};

Gop isup_leg On isup_pdu Match (m3pc, m3pc, cic) {
    Start (isup_msg=1);
};</pre>
<p>If no <span class="emphasis"><em>Start</em></span> is given for a Gop, a Pdu whose AVPL matches an existing Gog’s
key will act as the start of a Gop.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_what_goes_into_the_gops_avpl"></a>12.3.4.2.3. What goes into the Gop’s AVPL</h5></div></div></div>

<p>Once we know a Gop exists and the Pdu has been assigned to it, MATE will copy
into the Gop’s AVPL all the attributes matching the key plus any AVPs of the
Pdu’s AVPL matching the <span class="emphasis"><em>Extra</em></span> AVPL.</p>
<pre class="screen">Gop ftp_ses On ftp_pdu Match (addr, addr, port, port) {
    Start (ftp_cmd=USER);
    Extra (pasv_prt, pasv_addr);
};

Gop isup_leg On isup_pdu Match (m3pc, m3pc, cic) {
    Start (isup_msg=1);
    Extra (calling, called);
};</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_end_of_a_gop"></a>12.3.4.2.4. End of a Gop</h5></div></div></div>

<p>Once the Pdu has been assigned to the Gop, MATE will check whether or not the
Pdu matches the <span class="emphasis"><em>Stop</em></span>, if it happens, MATE will mark the Gop as stopped. Even
after stopped, a Gop may get assigned new Pdus matching its key, unless such
Pdu matches <span class="emphasis"><em>Start</em></span>. If it does, MATE will instead create a new Gop starting
with that Pdu.</p>
<pre class="screen">Gop ftp_ses On ftp_pdu Match (addr, addr, port, port) {
    Start (ftp_cmd=USER);
    Stop (ftp_cmd=QUIT); // The response to the QUIT command will be assigned to the same Gop
    Extra (pasv_prt, pasv_addr);
};

Gop dns_req On dns_pdu Match (addr, addr, dns_id) {
    Start (dns_resp=0);
    Stop (dns_resp=1);
};

Gop isup_leg On isup_pdu Match (m3pc, m3pc, cic) {
    Start (isup_msg=1); // IAM
    Stop (isup_msg=16); // RLC
    Extra (calling, called);
};</pre>
<p>If no <span class="emphasis"><em>Stop</em></span> criterium is stated for a given Gop, the Gop will be stopped as
soon as it is created. However, as with any other Gop, Pdus matching the Gop’s
key will still be assigned to the Gop unless they match a <span class="emphasis"><em>Start</em></span> condition,
in which case a new Gop using the same key will be created.</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_gops_tree"></a>12.3.4.3. Gop’s tree</h4></div></div></div>

<p>For every frame containing a Pdu that belongs to a Gop, MATE will create a tree
for that Gop.</p>
<p>The example below represents the tree created by the <span class="emphasis"><em>dns_pdu</em></span> and <span class="emphasis"><em>dns_req</em></span>
examples.</p>
<pre class="screen">...
mate dns_pdu:6-&gt;dns_req:1
    dns_pdu: 6
        dns_pdu time: 2.103063
        dns_pdu time since beginning of Gop: 2.103063
        dns_req: 1
            dns_req Attributes
                dns_id: 36012
                addr: 10.194.4.11
                addr: 10.194.24.35
            dns_req Times
                dns_req start time: 0.000000
                dns_req hold time: 2.103063
                dns_req duration: 2.103063
            dns_req number of PDUs: 2
                Start PDU: in frame 1
                Stop PDU: in frame 6 (2.103063 : 2.103063)
        dns_pdu Attributes
            dns_resp: 1
            dns_id: 36012
            addr: 10.194.4.11
            addr: 10.194.24.35</pre>
<p>Other than the pdu’s tree, this one contains information regarding the
relationship between the Pdus that belong to the Gop. That way we have:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
mate.dns_req which contains the id of this dns_req Gop. This will be present
in frames that belong to dns_req Gops.
</li><li class="listitem">
mate.dns_req.dns_id and mate.dns_req.addr which represent the values of the
attributes copied into the Gop.
</li><li class="listitem">
<p class="simpara">the timers of the Gop</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">
mate.dns_req.StartTime time (in seconds) passed since beginning of capture
until Gop’s start.
</li><li class="listitem">
mate.dns_req.Time time passed between the start Pdu and the stop Pdu assigned
to this Gop (only created if a Stop criterion has been declared for the Gop and
a matching Pdu has arrived).
</li><li class="listitem">
mate.dns_req.Duration time passed between the start Pdu and the last Pdu
assigned to this Gop.
</li></ul></div>
</li><li class="listitem">
<p class="simpara">mate.dns_req.NumOfPdus the number of Pdus that belong to this Gop</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">
a filterable list of frame numbers of the pdus of this Gop
</li></ul></div>
</li></ul></div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_gops_timers"></a>12.3.4.3.1. Gop’s timers</h5></div></div></div>

<p>Note that there are two "timers" for a Gop:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<span class="strong"><strong>Time</strong></span>, which is defined only for Gops that have been Stopped, and gives the
time passed between the <span class="emphasis"><em>Start</em></span> and the <span class="emphasis"><em>Stop</em></span> Pdus.
</li><li class="listitem">
<span class="strong"><strong>Duration</strong></span>, which is defined for every Gop regardless of its state, and give
the time passed between its <span class="emphasis"><em>Start</em></span> Pdu and the last Pdu that was assigned to
that Gop.
</li></ul></div>
<p>So:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
we can filter for Pdus that belong to Gops that have been Stopped with
<span class="strong"><strong>mate.xxx.Time</strong></span>
</li><li class="listitem">
we can filter for Pdus that belong to unstopped Gops with <span class="strong"><strong>mate.xxx &amp;&amp;
mate.xxx.Time</strong></span>
</li><li class="listitem">
we can filter for Pdus that belong to stopped Gops using <span class="strong"><strong>mate.xxx.Duration</strong></span>
</li><li class="listitem">
we can filter for Pdus that belong to Gops that have taken more (or less) time
that 0.5s to complete with <span class="strong"><strong>mate.xxx.Time &gt; 0.5</strong></span> (you can try these also as
color filters to find out when response times start to grow)
</li></ul></div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_grouping_gops_together_gog"></a>12.3.4.4. Grouping Gops together (Gog)</h4></div></div></div>

<p>When Gops are created, or whenever their AVPL changes, Gops are (re)analyzed to
check if they match an existent group of groups (Gog) or can create a new one.
The Gop analysis is divided into two phases. In the first phase, the still
unassigned Gop is checked to verify whether it belongs to an already existing
Gog or may create a new one. The second phase eventually checks the Gog and
registers its keys in the Gogs index.</p>
<div class="informalfigure">
<div class="mediaobject"><img src="images/ws-mate-gop_analysis.png" alt="ws mate gop analysis"></div>
</div>
<p>There are several reasons for the author to believe that this feature needs to
be reimplemented, so probably there will be deep changes in the way this is done
in the near future. This section of the documentation reflects the version of
MATE as of Wireshark 0.10.9; in future releases this will change.</p>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_declaring_a_group_of_groups"></a>12.3.4.4.1. Declaring a Group Of Groups</h5></div></div></div>

<p>The first thing we have to do configuring a Gog is to tell MATE that it exists.</p>
<pre class="screen">Gog web_use {
   ...
};</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_telling_mate_what_could_be_a_gog_member"></a>12.3.4.4.2. Telling MATE what could be a Gog member</h5></div></div></div>

<p>Then we have to tell MATE what to look for a match in the candidate Gops.</p>
<pre class="screen">Gog web_use {
    Member http_ses (host);
    Member dns_req (host);
};</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_getting_interesting_data_into_the_gop"></a>12.3.4.4.3. Getting interesting data into the Gop</h5></div></div></div>

<p>Most often, also other attributes than those used for matching would be
interesting. In order to copy from Gop to Gog other interesting attributes, we
might use <span class="emphasis"><em>Extra</em></span> like we do for Gops.</p>
<pre class="screen">Gog web_use {
    ...
    Extra (cookie);
};</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_gogs_tree"></a>12.3.4.4.4. Gog’s tree</h5></div></div></div>

<pre class="screen">mate http_pdu:4-&gt;http_req:2-&gt;http_use:1
    http_pdu: 4
        http_pdu time: 1.309847
        http_pdu time since beginning of Gop: 0.218930
        http_req: 2
            ... (the gop's tree for http_req: 2) ..
        http_use: 1
            http_use Attributes
                host: www.example.com
            http_use Times
                http_use start time: 0.000000
                http_use duration: 1.309847
            number of GOPs: 3
                dns_req: 1
                    ... (the gop's tree for dns_req: 1) ..
                http_req: 1
                    ... (the gop's tree for http_req: 1) ..
                http_req of current frame: 2</pre>
<p>We can filter on:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<span class="strong"><strong>mate.http_use.Duration</strong></span> time elapsed between the first frame of a Gog and the last one assigned to it.
</li><li class="listitem">
<p class="simpara">the attributes passed to the Gog</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">
<span class="strong"><strong>mate.http_use.host</strong></span>
</li></ul></div>
</li></ul></div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_avpl_transforms"></a>12.3.4.5. AVPL Transforms</h4></div></div></div>

<p>A Transform is a sequence of Match rules optionally completed with modification
of the match result by an additional AVPL. Such modification may be an Insert
(merge) or a Replace. Transforms can be used as helpers to manipulate an item’s
AVPL before it is processed further. They come to be very helpful in several
cases.</p>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_syntax"></a>12.3.4.5.1. Syntax</h5></div></div></div>

<p>AVPL Transformations are declared in the following way:</p>
<pre class="screen"> Transform name {
   Match [Strict|Every|Loose] match_avpl [Insert|Replace] modify_avpl ;
   ...
 };</pre>
<p>The <span class="strong"><strong>name</strong></span> is the handle to the AVPL transformation. It is used to refer to the
transform when invoking it later.</p>
<p>The <span class="emphasis"><em>Match</em></span> declarations instruct MATE what and how to match against the data
AVPL and how to modify the data AVPL if the match succeeds. They will be
executed in the order they appear in the config file whenever they are invoked.</p>
<p>The optional match mode qualifier (<span class="emphasis"><em>Strict</em></span>, <span class="emphasis"><em>Every</em></span>, or <span class="emphasis"><em>Loose</em></span>) is used
to choose the match mode as explained above; <span class="emphasis"><em>Strict</em></span> is a default value which
may be omitted.</p>
<p>The optional modification mode qualifier instructs MATE how the modify AVPL
should be used:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
the default value <span class="emphasis"><em>Insert</em></span> (which may be omitted) causes the <span class="emphasis"><em>modify_avpl</em></span>
to be <span class="strong"><strong>merged</strong></span> to the existing data AVPL,
</li><li class="listitem">
the <span class="emphasis"><em>Replace</em></span> causes all the matching AVPs from the data AVPL to be
<span class="strong"><strong>replaced</strong></span> by the <span class="emphasis"><em>modify_avpl</em></span>.
</li></ul></div>
<p>The <span class="emphasis"><em>modify_avpl</em></span> may be an empty one; this comes useful in some cases for
both <span class="emphasis"><em>Insert</em></span> and <span class="emphasis"><em>Replace</em></span> modification modes.</p>
<p>Examples:</p>
<pre class="screen"> Transform insert_name_and {
   Match Strict (host=10.10.10.10, port=2345) Insert (name=JohnDoe);
};</pre>
<p>adds name=JohnDoe to the data AVPL if it contains host=10.10.10.10 <span class="strong"><strong>and</strong></span>
port=2345</p>
<pre class="screen">Transform insert_name_or {
   Match Loose (host=10.10.10.10, port=2345) Insert (name=JohnDoe);
};</pre>
<p>adds name=JohnDoe to the data AVPL if it contains host=10.10.10.10 <span class="strong"><strong>or</strong></span>
port=2345</p>
<pre class="screen">Transform replace_ip_address {
   Match (host=10.10.10.10) Replace (host=192.168.10.10);
};</pre>
<p>replaces the original host=10.10.10.10 by host=192.168.10.10</p>
<pre class="screen">Transform add_ip_address {
   Match (host=10.10.10.10) (host=192.168.10.10);
};</pre>
<p>adds (inserts) host=192.168.10.10 to the AVPL, keeping the original
host=10.10.10.10 in it too</p>
<pre class="screen"> Transform replace_may_be_surprising {
   Match Loose (a=aaaa, b=bbbb) Replace (c=cccc, d=dddd);
 };</pre>
<p>gives the following results:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
(a=aaaa, b=eeee) gets transformed to (b=eeee, c=cccc, d=dddd) because a=aaaa
did match so it got replaced while b=eeee did not match so it has been left
intact,
</li><li class="listitem">
(a=aaaa, b=bbbb) gets transformed to (c=cccc, d=dddd) because both a=aaaa and
b=bbbb did match.
</li></ul></div>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_usage"></a>12.3.4.5.2. Usage</h5></div></div></div>

<p>Once declared, Transforms can be added to the declarations of PDUs, Gops or
Gogs. This is done by adding the <span class="emphasis"><em>Transform name_list</em></span> statement to the
declaration:</p>
<pre class="screen">Pdu my_proto_pdu Proto my_proto Transport ip {
    Extract addr From ip.addr;
    ...
    Transform my_pdu_transform[, other_pdu_transform[, yet_another_pdu_transform]];
};</pre>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
In case of PDU, the list of transforms is applied against the PDU’s AVPL
after its creation.
</li><li class="listitem">
In case of Gop and Gog, the list of transforms is applied against their
respective AVPLs when they are created and every time they change.
</li></ul></div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_operation"></a>12.3.4.6. Operation</h4></div></div></div>

<div class="informalfigure">
<div class="mediaobject"><img src="images/ws-mate-transform.png" alt="ws mate transform"></div>
</div>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
A list of previously declared Transforms may be given to every Item (Pdu, Gop,
or Gog), using the Transform statement.
</li><li class="listitem">
Every time the AVPL of an item changes, it will be operated against <span class="strong"><strong>all</strong></span> the
Transforms on the list given to that item. The Transforms on the list are
applied left to right.
</li><li class="listitem">
Inside each of the Transforms, the item’s AVPL will be operated against the
Transform’s Match clauses starting from the topmost one, until all have been
tried or until one of them succeeds.
</li></ul></div>
<p>MATE’s Transforms can be used for many different things, like:</p>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_multiple_startstop_conditions_for_a_gop"></a>12.3.4.6.1. Multiple Start/Stop conditions for a Gop</h5></div></div></div>

<p>Using <span class="emphasis"><em>Transforms</em></span> we can add more than one start or stop condition to a Gop.</p>
<pre class="screen">Transform start_cond {
  Match (attr1=aaa,attr2=bbb) (msg_type=start);
  Match (attr3=www,attr2=bbb) (msg_type=start);
  Match (attr5^a) (msg_type=stop);
  Match (attr6$z) (msg_type=stop);
};

Pdu pdu ... {
  ...
  Transform start_cond;
}

Gop gop ... {
  Start (msg_type=start);
  Stop (msg_type=stop);
  ...
}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_marking_gops_and_gogs_to_filter_them_easily"></a>12.3.4.6.2. Marking Gops and Gogs to filter them easily</h5></div></div></div>

<pre class="screen">Transform marks {
  Match (addr=10.10.10.10, user=john) (john_at_host);
  Match (addr=10.10.10.10, user=tom) (tom_at_host);
}

...

Gop my_gop ... {
  ...
  Transform marks;
}</pre>
<p>After that we can use a display filter <span class="strong"><strong>mate.gop.john_at_host</strong></span> or
<span class="strong"><strong>mate.gop.tom_at_host</strong></span></p>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_adding_direction_knowledge_to_mate"></a>12.3.4.6.3. Adding direction knowledge to MATE</h5></div></div></div>

<pre class="screen">Transform direction_as_text {
  Match (src=192.168.0.2, dst=192.168.0.3) Replace (direction=from_2_to_3);
  Match (src=192.168.0.3, dst=192.168.0.2) Replace (direction=from_3_to_2);
};

Pdu my_pdu Proto my_proto Transport tcp/ip {
  Extract src From ip.src;
  Extract dst From ip.dst;
  Extract addr From ip.addr;
  Extract port From tcp.port;
  Extract start From tcp.flags.syn;
  Extract stop From tcp.flags.fin;
  Extract stop From tcp.flags.rst;
  Transform direction_as_text;
}

Gop my_gop On my_pdu Match (addr,addr,port,port) {
  ...
  Extra (direction);
}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_nat"></a>12.3.4.6.4. NAT</h5></div></div></div>

<p>NAT can create problems when tracing, but we can easily work around it by
Transforming the NATed IP address and the Ethernet address of the router into
the non-NAT address:</p>
<pre class="screen">Transform denat {
  Match (addr=192.168.0.5, ether=01:02:03:04:05:06) Replace (addr=123.45.67.89);
  Match (addr=192.168.0.6, ether=01:02:03:04:05:06) Replace (addr=123.45.67.90);
  Match (addr=192.168.0.7, ether=01:02:03:04:05:06) Replace (addr=123.45.67.91);
}

Pdu my_pdu Proto my_proto transport tcp/ip/eth {
  Extract ether From eth.addr;
  Extract addr From ip.addr;
  Extract port From tcp.port;
  Transform denat;
}</pre>
</div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_about_mate"></a>12.3.5. About MATE</h3></div></div></div>

<p>MATE was originally written by Luis Ontanon, a Telecommunications systems
troubleshooter, as a way to save time filtering out the packets of a single call
from huge capture files using just the calling number. Later he used the time he
had saved to make it flexible enough to work with protocols other than the ones
he was directly involved with.</p>
</div>
</div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ChMateGettingStarted.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ChMate.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ChMateConfigurationTutorial.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">12.2. Getting Started </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 12.4. MATE’s configuration tutorial</td></tr></table></div></body></html>
