<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>6.4. Building Display Filter Expressions</title><link rel="stylesheet" type="text/css" href="ws.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="Wireshark User’s Guide"><link rel="up" href="ChapterWork.html" title="Chapter 6. Working With Captured Packets"><link rel="prev" href="ChWorkDisplayFilterSection.html" title="6.3. Filtering Packets While Viewing"><link rel="next" href="ChWorkFilterAddExpressionSection.html" title="6.5. The “Display Filter Expression” Dialog Box"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">6.4. Building Display Filter Expressions</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ChWorkDisplayFilterSection.html">Prev</a> </td><th width="60%" align="center">Chapter 6. Working With Captured Packets</th><td width="20%" align="right"> <a accesskey="n" href="ChWorkFilterAddExpressionSection.html">Next</a></td></tr></table><hr></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ChWorkBuildDisplayFilterSection"></a>6.4. Building Display Filter Expressions</h2></div></div></div>

<p>Wireshark provides a display filter language that enables you
to precisely control which packets are displayed. They can be used
to check for the presence of a protocol or field, the value of a field, or
even compare two fields to each other. These comparisons can be combined
with logical operators, like "and" and "or", and parentheses
into complex expressions.</p>
<p>The following sections will go into the display filter functionality in
more detail.</p>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.svg"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
<p>There are many display filter examples on the <span class="emphasis"><em>Wireshark Wiki Display
Filter page</em></span> at: <a class="ulink" href="https://gitlab.com/wireshark/wireshark/-/wikis/DisplayFilters" target="_top">https://gitlab.com/wireshark/wireshark/-/wikis/DisplayFilters</a>.</p>
</td></tr></table></div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_display_filter_fields"></a>6.4.1. Display Filter Fields</h3></div></div></div>

<p>The simplest display filter is one that displays a single protocol.
To only display packets containing a particular protocol, type the protocol
into Wireshark’s display filter toolbar. For example, to only
display TCP packets, type <span class="emphasis"><em>tcp</em></span> into Wireshark’s display filter toolbar.
Similarly, to only display
packets containing a particular field, type the field
into Wireshark’s display filter toolbar. For example, to only display
HTTP requests, type <span class="emphasis"><em>http.request</em></span> into Wireshark’s display filter toolbar.</p>
<p>You can filter on any protocol that Wireshark supports. You can
also filter on any field that a dissector adds to the tree view, if the dissector
has added an abbreviation for that field. A full list of the available protocols
and fields is available through the menu item
<span class="guimenu">View</span> → <span class="guisubmenu">Internals</span> → <span class="guimenuitem">Supported Protocols</span>.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_comparing_values"></a>6.4.2. Comparing Values</h3></div></div></div>

<p>You can build display filters that compare values using a number of different
comparison operators. For example, to only display packets to or
from the IP address 192.168.0.1, use <code class="literal">ip.addr==192.168.0.1</code>.</p>
<p>A complete list of available comparison operators is shown in <a class="xref" href="ChWorkBuildDisplayFilterSection.html#DispCompOps" title="Table 6.6. Display Filter comparison operators">Table 6.6, “Display Filter comparison operators”</a>.</p>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.svg"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
<p>English and C-like operators are interchangeable and can be mixed within a filter string.</p>
</td></tr></table></div>
<div class="table"><a name="DispCompOps"></a><p class="title"><b>Table 6.6. Display Filter comparison operators</b></p><div class="table-contents">

<table class="table" summary="Display Filter comparison operators" border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"><col class="col_4"><col class="col_5"></colgroup><thead><tr><th align="left" valign="top">English</th><th align="left" valign="top">Alias</th><th align="left" valign="top">C-like</th><th align="left" valign="top">Description</th><th align="left" valign="top">Example</th></tr></thead><tbody><tr><td align="left" valign="top"><p>eq</p></td><td align="left" valign="top"><p>any_eq</p></td><td align="left" valign="top"><p>==</p></td><td align="left" valign="top"><p>Equal (any if more than one)</p></td><td align="left" valign="top"><p><code class="literal">ip.src == 10.0.0.5</code></p></td></tr><tr><td align="left" valign="top"><p>ne</p></td><td align="left" valign="top"><p>all_ne</p></td><td align="left" valign="top"><p>!=</p></td><td align="left" valign="top"><p>Not equal (all if more than one)</p></td><td align="left" valign="top"><p><code class="literal">ip.src != 10.0.0.5</code></p></td></tr><tr><td align="left" valign="top"> </td><td align="left" valign="top"><p>all_eq</p></td><td align="left" valign="top"><p>===</p></td><td align="left" valign="top"><p>Equal (all if more than one)</p></td><td align="left" valign="top"><p><code class="literal">ip.src === 10.0.0.5</code></p></td></tr><tr><td align="left" valign="top"> </td><td align="left" valign="top"><p>any_ne</p></td><td align="left" valign="top"><p>!==</p></td><td align="left" valign="top"><p>Not equal (any if more than one)</p></td><td align="left" valign="top"><p><code class="literal">ip.src !== 10.0.0.5</code></p></td></tr><tr><td align="left" valign="top"><p>gt</p></td><td align="left" valign="top"> </td><td align="left" valign="top"><p>&gt;</p></td><td align="left" valign="top"><p>Greater than</p></td><td align="left" valign="top"><p><code class="literal">frame.len &gt; 10</code></p></td></tr><tr><td align="left" valign="top"><p>lt</p></td><td align="left" valign="top"> </td><td align="left" valign="top"><p>&lt;</p></td><td align="left" valign="top"><p>Less than</p></td><td align="left" valign="top"><p><code class="literal">frame.len &lt; 128</code></p></td></tr><tr><td align="left" valign="top"><p>ge</p></td><td align="left" valign="top"> </td><td align="left" valign="top"><p>&gt;=</p></td><td align="left" valign="top"><p>Greater than or equal to</p></td><td align="left" valign="top"><p><code class="literal">frame.len ge 0x100</code></p></td></tr><tr><td align="left" valign="top"><p>le</p></td><td align="left" valign="top"> </td><td align="left" valign="top"><p>&lt;=</p></td><td align="left" valign="top"><p>Less than or equal to</p></td><td align="left" valign="top"><p><code class="literal">frame.len &lt;= 0x20</code></p></td></tr><tr><td align="left" valign="top"><p>contains</p></td><td align="left" valign="top"> </td><td align="left" valign="top"> </td><td align="left" valign="top"><p>Protocol, field or slice contains a value</p></td><td align="left" valign="top"><p><code class="literal">sip.To contains "a1762"</code></p></td></tr><tr><td align="left" valign="top"><p>matches</p></td><td align="left" valign="top"> </td><td align="left" valign="top"><p>~</p></td><td align="left" valign="top"><p>Protocol or text field matches a Perl-compatible regular expression</p></td><td align="left" valign="top"><p><code class="literal">http.host matches "acme\\.(org|com|net)"</code></p></td></tr></tbody></table>
</div></div><br class="table-break">
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.svg"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>The meaning of != (all not equal) was changed in Wireshark 3.6.
Before it used to mean "any not equal".</p>
</td></tr></table></div>
<p>All protocol fields have a type. <a class="xref" href="ChWorkBuildDisplayFilterSection.html#ChWorkFieldTypes" title="6.4.2.1. Display Filter Field Types">Section 6.4.2.1, “Display Filter Field Types”</a> provides a list
of the types with examples of how to use them in display filters.</p>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="ChWorkFieldTypes"></a>6.4.2.1. Display Filter Field Types</h4></div></div></div>

<div class="variablelist"><dl class="variablelist"><dt><span class="term">Unsigned integer</span></dt><dd>
<p class="simpara">Can be 8, 16, 24, 32, or 64 bits. You can express integers in decimal, octal,
hexadecimal or binary. The following display filters are equivalent:</p>
<p class="simpara"><code class="literal">ip.len le 1500</code></p>
<p class="simpara"><code class="literal">ip.len le 02734</code></p>
<p class="simpara"><code class="literal">ip.len le 0x5dc</code></p>
<p class="simpara"><code class="literal">ip.len le 0b10111011100</code></p>
</dd><dt><span class="term">Signed integer</span></dt><dd>
Can be 8, 16, 24, 32, or 64 bits. As with unsigned integers you can use
decimal, octal, hexadecimal or binary.
</dd><dt><span class="term">Boolean</span></dt><dd>
<p class="simpara">Can be 1 or "True" or "TRUE", 0 or "False" or "FALSE" (without quotes).</p>
<p class="simpara">A Boolean field is present regardless if its value is true or false. For example,
<code class="literal">tcp.flags.syn</code> is present in all TCP packets containing the flag, whether
the SYN flag is 0 or 1. To only match TCP packets with the SYN flag set, you need
to use <code class="literal">tcp.flags.syn == 1</code> or <code class="literal">tcp.flags.syn == True</code>.</p>
</dd><dt><span class="term">Ethernet address</span></dt><dd>
<p class="simpara">6 bytes separated by a colon (:), dot (.), or dash (-) with one or two bytes between separators:</p>
<p class="simpara"><code class="literal">eth.dst == ff:ff:ff:ff:ff:ff</code></p>
<p class="simpara"><code class="literal">eth.dst == ff-ff-ff-ff-ff-ff</code></p>
<p class="simpara"><code class="literal">eth.dst == ffff.ffff.ffff</code></p>
</dd><dt><span class="term">IPv4 address</span></dt><dd>
<p class="simpara"><code class="literal">ip.addr == 192.168.0.1</code></p>
<p class="simpara">Classless InterDomain Routing (CIDR) notation can be used to test if
an IPv4 address is in a certain subnet. For example, this display
filter will find all packets in the 129.111 Class-B network:</p>
<p class="simpara"><code class="literal">ip.addr == 129.111.0.0/16</code></p>
</dd><dt><span class="term">IPv6 address</span></dt><dd>
<p class="simpara"><code class="literal">ipv6.addr == ::1</code></p>
<p class="simpara">As with IPv4 addresses, IPv6 addresses can match a subnet.</p>
</dd><dt><span class="term">Text string</span></dt><dd>
<p class="simpara"><code class="literal">http.request.uri == "https://www.wireshark.org/"</code></p>
<p class="simpara">Strings are a sequence of bytes. Functions like <code class="literal">lower()</code> use ASCII, otherwise
no particular encoding is assumed. String literals are specified with double
quotes. Characters can also be specified using a byte escape sequence using
hex \x<span class="emphasis"><em>hh</em></span> or octal \<span class="emphasis"><em>ddd</em></span>, where <span class="emphasis"><em>h</em></span> and <span class="emphasis"><em>d</em></span> are hex and octal
numerical digits respectively:</p>
<p class="simpara"><code class="literal">dns.qry.name contains "www.\x77\x69\x72\x65\x73\x68\x61\x72\x6b.org"</code></p>
<p class="simpara">Alternatively, a raw string syntax can be used. Such strings are prefixed with <code class="literal">r</code> or <code class="literal">R</code> and treat
backslash as a literal character.</p>
<p class="simpara"><code class="literal">http.user_agent matches r"\(X11;"</code></p>
</dd><dt><span class="term">Date and time</span></dt><dd>
<p class="simpara"><code class="literal">frame.time == "Sep 26, 2004 23:18:04.954975"</code></p>
<p class="simpara"><code class="literal">ntp.xmt ge "2020-07-04 12:34:56"</code></p>
<p class="simpara">The value of an absolute time field is expressed as a string, using one of the
two formats above. Fractional seconds can be omitted or specified up to
nanosecond precision; extra trailing zeros are allowed but not other digits.
The string cannot take a time zone suffix, and is always parsed as in the local
time zone, even for fields that are displayed in UTC.</p>
<p class="simpara">In the first format, the abbreviated month names must be in English regardless
of locale. In the second format, any number of time fields may be omitted, in
the order from least significant (seconds) to most, but at least the entire
date must be specified:</p>
<p class="simpara"><code class="literal">frame.time &lt; "2022-01-01"</code></p>
<p class="simpara">In the second format, a <code class="literal">T</code> may appear between the date and time as in
ISO 8601, but not when less significant times are dropped.</p>
</dd></dl></div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="ChWorkFilterExamples"></a>6.4.2.2. Some Examples</h4></div></div></div>

<pre class="screen">udp contains 81:60:03</pre>
<p>The display filter above matches packets that contains the 3-byte sequence 0x81, 0x60,
0x03 anywhere in the UDP header or payload.</p>
<pre class="screen">sip.To contains "a1762"</pre>
<p>The display filter above matches packets where the SIP To-header contains the string "a1762"
anywhere in the header.</p>
<pre class="screen">http.host matches "acme\\.(org|com|net)"</pre>
<p>The display filter above matches HTTP packets where the HOST header contains
acme.org, acme.com, or acme.net.
Comparisons are case-insensitive.</p>
<pre class="screen">tcp.flags &amp; 0x02</pre>
<p>That display filter will match all packets that contain the “tcp.flags” field with the 0x02 bit,
i.e., the SYN bit, set.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_possible_pitfalls_using_regular_expressions"></a>6.4.2.3. Possible Pitfalls Using Regular Expressions</h4></div></div></div>

<p>String literals containing regular expressions are parsed twice. Once by Wireshark’s display
filter engine and again by the PCRE2 library. It’s important to keep this in mind when using
the "matches" operator with regex escape sequences and special characters.</p>
<p>For example, the filter expression <code class="literal">frame matches "AB\x43"</code> uses the string <code class="literal">"ABC"</code> as input
pattern to PCRE. However, the expression <code class="literal">frame matches "AB\\x43"</code> uses the string <code class="literal">"AB\x43"</code>
as the pattern. In this case both expressions give the same result because Wireshark and PCRE
both support the same byte escape sequence (0x43 is the ASCII hex code for <code class="literal">C</code>).</p>
<p>An example where this fails badly is <code class="literal">foo matches "bar\x28"</code>. Because 0x28 is the ASCII
code for <code class="literal">(</code> the pattern input to PCRE is <code class="literal">"bar("</code>. This regular expression is syntactically
invalid (missing closing parenthesis). To match a literal parenthesis in a display filter regular
expression it must be escaped (twice) with backslashes.</p>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.svg"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
<p>Using raw strings avoids most problem with the "matches" operator and double escape requirements.</p>
</td></tr></table></div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_combining_expressions"></a>6.4.3. Combining Expressions</h3></div></div></div>

<p>You can combine filter expressions in Wireshark using the logical operators shown in <a class="xref" href="ChWorkBuildDisplayFilterSection.html#FiltLogOps" title="Table 6.7. Display Filter Logical Operations">Table 6.7, “Display Filter Logical Operations”</a></p>
<div class="table"><a name="FiltLogOps"></a><p class="title"><b>Table 6.7. Display Filter Logical Operations</b></p><div class="table-contents">

<table class="table" summary="Display Filter Logical Operations" border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"><col class="col_4"></colgroup><thead><tr><th align="left" valign="top">English</th><th align="left" valign="top">C-like</th><th align="left" valign="top">Description</th><th align="left" valign="top">Example</th></tr></thead><tbody><tr><td align="left" valign="top"><p>and</p></td><td align="left" valign="top"><p>&amp;&amp;</p></td><td align="left" valign="top"><p>Logical AND</p></td><td align="left" valign="top"><p><code class="literal">ip.src==10.0.0.5 and tcp.flags.fin</code></p></td></tr><tr><td align="left" valign="top"><p>or</p></td><td align="left" valign="top"><p>||</p></td><td align="left" valign="top"><p>Logical OR</p></td><td align="left" valign="top"><p><code class="literal">ip.src==10.0.0.5 or ip.src==192.1.1.1</code></p></td></tr><tr><td align="left" valign="top"><p>xor</p></td><td align="left" valign="top"><p>^^</p></td><td align="left" valign="top"><p>Logical XOR</p></td><td align="left" valign="top"><p><code class="literal">tr.dst[0:3] == 0.6.29 xor tr.src[0:3] == 0.6.29</code></p></td></tr><tr><td align="left" valign="top"><p>not</p></td><td align="left" valign="top"><p>!</p></td><td align="left" valign="top"><p>Logical NOT</p></td><td align="left" valign="top"><p><code class="literal">not llc</code></p></td></tr><tr><td align="left" valign="top"><p>[…​]</p></td><td align="left" valign="top"> </td><td align="left" valign="top"><p>Subsequence</p></td><td align="left" valign="top"><p>See “Slice Operator” below.</p></td></tr><tr><td align="left" valign="top"><p>in</p></td><td align="left" valign="top"> </td><td align="left" valign="top"><p>Set Membership</p></td><td align="left" valign="top"><p>http.request.method in {"HEAD", "GET"}. See “Membership Operator” below.</p></td></tr></tbody></table>
</div></div><br class="table-break">
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_slice_operator"></a>6.4.4. Slice Operator</h3></div></div></div>

<p>Wireshark allows you to select a subsequence of a sequence in rather elaborate
ways. After a label you can place a pair of brackets [] containing a comma
separated list of range specifiers.</p>
<pre class="screen">eth.src[0:3] == 00:00:83</pre>
<p>The example above uses the n:m format to specify a single range. In this case n
is the beginning offset and m is the length of the range being specified.</p>
<pre class="screen">eth.src[1-2] == 00:83</pre>
<p>The example above uses the n-m format to specify a single range. In this case n
is the beginning offset and m is the ending offset.</p>
<pre class="screen">eth.src[:4] == 00:00:83:00</pre>
<p>The example above uses the :m format, which takes everything from the beginning
of a sequence to offset m. It is equivalent to 0:m</p>
<pre class="screen">eth.src[4:] == 20:20</pre>
<p>The example above uses the n: format, which takes everything from offset n to
the end of the sequence.</p>
<pre class="screen">eth.src[2] == 83</pre>
<p>The example above uses the n format to specify a single range. In this case the
element in the sequence at offset n is selected. This is equivalent to n:1.</p>
<pre class="screen">eth.src[0:3,1-2,:4,4:,2] ==
00:00:83:00:83:00:00:83:00:20:20:83</pre>
<p>Wireshark allows you to string together single ranges in a comma separated list
to form compound ranges as shown above.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_membership_operator"></a>6.4.5. Membership Operator</h3></div></div></div>

<p>Wireshark allows you to test a field for membership in a set of values or
fields. After the field name, use the <code class="literal">in</code> operator followed by the set items
surrounded by braces {}. For example, to display packets with a TCP source or
destination port of 80, 443, or 8080, you can use <code class="literal">tcp.port in {80, 443, 8080}</code>.
Set elements must be separated by commas.
The set of values can also contain ranges: <code class="literal">tcp.port in {443,4430..4434}</code>.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.svg"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
<p>The display filter</p>
<pre class="screen">tcp.port in {80, 443, 8080}</pre>
<p>is equivalent to</p>
<pre class="screen">tcp.port == 80 || tcp.port == 443 || tcp.port == 8080</pre>
<p>However, the display filter</p>
<pre class="screen">tcp.port in {443, 4430..4434}</pre>
<p>is not equivalent to</p>
<pre class="screen">tcp.port == 443 || (tcp.port &gt;= 4430 &amp;&amp; tcp.port &lt;= 4434)</pre>
<p>This is because comparison operators are satisfied when <span class="emphasis"><em>any</em></span> field
matches the filter, so a packet with a source port of 56789 and
destination port of port 80 would also match the second filter
since <code class="literal">56789 &gt;= 4430 &amp;&amp; 80 &lt;= 4434</code> is true. In contrast, the
membership operator tests a single field against the range condition.</p>
</td></tr></table></div>
<p>Sets are not just limited to numbers, other types can be used as well:</p>
<pre class="screen">http.request.method in {"HEAD", "GET"}
ip.addr in {10.0.0.5 .. 10.0.0.9, 192.168.1.1..192.168.1.9}
frame.time_delta in {10 .. 10.5}</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_arithmetic_operators"></a>6.4.6. Arithmetic operators</h3></div></div></div>

<p>You can perform the arithmetic operations on numeric fields shown in <a class="xref" href="ChWorkBuildDisplayFilterSection.html#ArithmeticOps" title="Table 6.8. Display Filter Arithmetic Operations">Table 6.8, “Display Filter Arithmetic Operations”</a></p>
<div class="table"><a name="ArithmeticOps"></a><p class="title"><b>Table 6.8. Display Filter Arithmetic Operations</b></p><div class="table-contents">

<table class="table" summary="Display Filter Arithmetic Operations" border="1"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top">Name</th><th align="left" valign="top">Syntax</th><th align="left" valign="top">Description</th></tr></thead><tbody><tr><td align="left" valign="top"><p>Unary minus</p></td><td align="left" valign="top"><p>-A</p></td><td align="left" valign="top"><p>Negation of A</p></td></tr><tr><td align="left" valign="top"><p>Addition</p></td><td align="left" valign="top"><p>A + B</p></td><td align="left" valign="top"><p>Add B to A</p></td></tr><tr><td align="left" valign="top"><p>Subtraction</p></td><td align="left" valign="top"><p>A - B</p></td><td align="left" valign="top"><p>Subtract B from A</p></td></tr><tr><td align="left" valign="top"><p>Multiplication</p></td><td align="left" valign="top"><p>A * B</p></td><td align="left" valign="top"><p>Multiply A times B</p></td></tr><tr><td align="left" valign="top"><p>Division</p></td><td align="left" valign="top"><p>A / B</p></td><td align="left" valign="top"><p>Divide A by B</p></td></tr><tr><td align="left" valign="top"><p>Modulo</p></td><td align="left" valign="top"><p>A % B</p></td><td align="left" valign="top"><p>Remainder of A divided by B</p></td></tr><tr><td align="left" valign="top"><p>Bitwise AND</p></td><td align="left" valign="top"><p>A &amp; B</p></td><td align="left" valign="top"><p>Bitwise AND of A and B</p></td></tr></tbody></table>
</div></div><br class="table-break">
<p>Arithmetic expressions can be grouped using curly braces.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_functions"></a>6.4.7. Functions</h3></div></div></div>

<p>The display filter language has a number of functions to convert fields, see
<a class="xref" href="ChWorkBuildDisplayFilterSection.html#DispFunctions" title="Table 6.9. Display Filter Functions">Table 6.9, “Display Filter Functions”</a>.</p>
<div class="table"><a name="DispFunctions"></a><p class="title"><b>Table 6.9. Display Filter Functions</b></p><div class="table-contents">

<table class="table" summary="Display Filter Functions" border="1"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="left" valign="top">Function</th><th align="left" valign="top">Description</th></tr></thead><tbody><tr><td align="left" valign="top"><p>upper</p></td><td align="left" valign="top"><p>Converts a string field to uppercase.</p></td></tr><tr><td align="left" valign="top"><p>lower</p></td><td align="left" valign="top"><p>Converts a string field to lowercase.</p></td></tr><tr><td align="left" valign="top"><p>len</p></td><td align="left" valign="top"><p>Returns the byte length of a string or bytes field.</p></td></tr><tr><td align="left" valign="top"><p>count</p></td><td align="left" valign="top"><p>Returns the number of field occurrences in a frame.</p></td></tr><tr><td align="left" valign="top"><p>string</p></td><td align="left" valign="top"><p>Converts a non-string field to a string.</p></td></tr><tr><td align="left" valign="top"><p>max</p></td><td align="left" valign="top"><p>Return the maximum value for the arguments.</p></td></tr><tr><td align="left" valign="top"><p>min</p></td><td align="left" valign="top"><p>Return the minimum value for the arguments.</p></td></tr><tr><td align="left" valign="top"><p>abs</p></td><td align="left" valign="top"><p>Return the absolute value for the argument.</p></td></tr></tbody></table>
</div></div><br class="table-break">
<p>The <code class="literal">upper</code> and <code class="literal">lower</code> functions can used to force case-insensitive matches:
<code class="literal">lower(http.server) contains "apache"</code>.</p>
<p>To find HTTP requests with long request URIs: <code class="literal">len(http.request.uri) &gt; 100</code>.
Note that the <code class="literal">len</code> function yields the string length in bytes rather than
(multi-byte) characters.</p>
<p>Usually an IP frame has only two addresses (source and destination), but in case
of ICMP errors or tunneling, a single packet might contain even more addresses.
These packets can be found with <code class="literal">count(ip.addr) &gt; 2</code>.</p>
<p>The <code class="literal">string</code> function converts a field value to a string, suitable for use with operators
like "matches" or "contains". Integer fields are converted to their decimal representation.
It can be used with IP/Ethernet addresses (as well as others), but not with string or
byte fields.</p>
<p>For example, to match odd frame numbers:</p>
<pre class="screen">string(frame.number) matches "[13579]$"</pre>
<p>To match IP addresses ending in 255 in a block of subnets (172.16 to 172.31):</p>
<pre class="screen">string(ip.dst) matches r"^172\.(1[6-9]|2[0-9]|3[0-1])\.[0-9]{1,3}\.255"</pre>
<p>The functions max() and min() take any number of arguments of the same type
and returns the largest/smallest respectively of the set.</p>
<pre class="screen">max(tcp.srcport, tcp.dstport) &lt;= 1024</pre>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="ChWorkBuildDisplayFilterTransitional"></a>6.4.8. Sometimes Fields Change Names</h3></div></div></div>

<p>As protocols evolve they sometimes change names or are superseded by
newer standards. For example, DHCP extends and has largely replaced
BOOTP and TLS has replaced SSL. If a protocol dissector originally used
the older names and fields for a protocol the Wireshark development team
might update it to use the newer names and fields. In such cases they
will add an alias from the old protocol name to the new one in order to
make the transition easier.</p>
<p>For example, the DHCP dissector was originally developed for the BOOTP
protocol but as of Wireshark 3.0 all of the “bootp” display filter
fields have been renamed to their “dhcp” equivalents. You can still use
the old filter names for the time being, e.g., “bootp.type” is equivalent
to “dhcp.type” but Wireshark will show the warning “"bootp" is deprecated”
when you use it. Support for the deprecated fields may be removed in the future.</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_some_protocol_names_can_be_ambiguous"></a>6.4.9. Some protocol names can be ambiguous</h3></div></div></div>

<p>In some particular cases relational expressions (equal, less than, etc.)
can be ambiguous. The filter name of a protocol or protocol field can contain
any letter and digit in any order, possibly separated by dots. That can be
indistinguishable from a literal value (usually numerical values in hexadecimal).
For example the semantic value of <code class="literal">fc</code> can be the protocol Fibre Channel or the
number 0xFC in hexadecimal because the 0x prefix is optional for hexadecimal numbers.</p>
<p>Any value that matches a registered protocol or protocol field filter name is
interpreted semantically as such. If it doesn’t match a protocol name the normal
rules for parsing literal values apply.</p>
<p>So in the case of 'fc' the lexical token is interpreted as "Fibre Channel" and
not 0xFC. In the case of 'fd' it would be interpreted as 0xFD because it is a
well-formed hexadecimal literal value (according to the rules of display filter
language syntax) and there is no protocol registered with the filter name 'fd'.</p>
<p>How ambiguous values are interpreted may change in the future. To avoid this
problem and resolve the ambiguity there is additional syntax available.
Values prefixed with a dot are always treated as a protocol name. The
dot stands for the root of the protocol namespace and is optional). Values
prefixed with a colon are always interpreted as a byte array.</p>
<pre class="screen">frame[10:] contains .fc or frame[10] == :fc</pre>
<p>If you are writing a script, or you think your expression may not be giving the
expected results because of the syntactical ambiguity of some filter expression
it is advisable to use the explicit syntax to indicate the correct meaning for
that expression.</p>
</div>
</div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ChWorkDisplayFilterSection.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ChapterWork.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ChWorkFilterAddExpressionSection.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">6.3. Filtering Packets While Viewing </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 6.5. The “Display Filter Expression” Dialog Box</td></tr></table></div></body></html>
