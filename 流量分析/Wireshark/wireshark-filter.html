<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.17">
<title>wireshark-filter(4)</title>
<link rel="stylesheet" href="./ws.css">
</head>
<body class="manpage">
<div id="header">
<h1>wireshark-filter(4) Manual Page</h1>
<h2 id="_name">NAME</h2>
<div class="sectionbody">
<p>wireshark-filter - Wireshark display filter syntax and reference</p>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_synopsis">SYNOPSIS</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>wireshark</strong> [other options]
<span class="nowrap">[ <strong>-Y</strong> "display filter expression" | <strong>--display-filter</strong> "display filter expression" ]</span></p>
</div>
<div class="paragraph">
<p><strong>tshark</strong> [other options]
<span class="nowrap">[ <strong>-Y</strong> "display filter expression" | <strong>--display-filter</strong> "display filter expression" ]</span></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_description">DESCRIPTION</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Wireshark</strong> and <strong>TShark</strong> share a powerful filter engine that helps remove
the noise from a packet trace and lets you see only the packets that interest
you.  If a packet meets the requirements expressed in your filter, then it
is displayed in the list of packets.  Display filters let you compare the
fields within a protocol against a specific value, compare fields against
fields, and check the existence of specified fields or protocols.</p>
</div>
<div class="paragraph">
<p>Filters are also used by other features such as statistics generation and
packet list colorization (the latter is only available to <strong>Wireshark</strong>). This
manual page describes their syntax. A comprehensive reference of filter fields
can be found within Wireshark and in the display filter reference at
<a href="https://www.wireshark.org/docs/dfref/" class="bare">https://www.wireshark.org/docs/dfref/</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_filter_syntax">FILTER SYNTAX</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_check_whether_a_field_or_protocol_exists">Check whether a field or protocol exists</h3>
<div class="paragraph">
<p>The simplest filter allows you to check for the existence of a protocol or
field.  If you want to see all packets which contain the IP protocol, the
filter would be "ip" (without the quotation marks). To see all packets
that contain a Token-Ring RIF field, use "tr.rif".</p>
</div>
<div class="paragraph">
<p>Whenever a protocol or field appears as the argument of a function in a filter,
an exists operator for that protocol or field implicitly appears.</p>
</div>
</div>
<div class="sect2">
<h3 id="_values_and_operators">Values and operators</h3>
<div class="paragraph">
<p>Each field has a value, and that value can be used in operations with
comparable values (which may be literals, other fields, or function results).
The value of a field is not necessarily what appears in the <strong>Wireshark</strong>
display or <strong>TShark</strong> output.  For example, a protocol is semantically
equivalent to the sequence of bytes that it spans, not its displayed text
in the protocol tree.</p>
</div>
</div>
<div class="sect2">
<h3 id="_comparison_operators">Comparison operators</h3>
<div class="paragraph">
<p>The comparison operators can be expressed either through English-like
abbreviations or through C-like symbols:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>eq, ==    Equal
ne, !=    Not Equal
gt, &gt;     Greater Than
lt, &lt;     Less Than
ge, &gt;=    Greater than or Equal to
le, &lt;=    Less than or Equal to</pre>
</div>
</div>
<div class="paragraph">
<p>The ordering depends on the value type in the usual way (e.g., lexicographic
for strings and arithmetic for integers.)  A field may appear more than once
in a given frame.  In that case equality can be strict (all fields must match
the condition) or not (any field must match the condition). The inequality is
the logical negation of equality. The following table contains all equality
operators, their aliases and meaning:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>eq, any_eq, ==    Any field must be equal
ne, all_ne, !=    All fields must be not equal
    all_eq, ===   All fields must be equal
    any_ne, !==   Any fields must be not equal</pre>
</div>
</div>
<div class="paragraph">
<p>The operators "any" or "all" can be used with any comparison operator to make
the test match any or all fields:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>all tcp.port &gt; 1024</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>any ip.addr != 1.1.1.1</pre>
</div>
</div>
<div class="paragraph">
<p>The "any" and "all" modifiers take precedence over comparison operators such
as "===" and "any_eq".</p>
</div>
</div>
<div class="sect2">
<h3 id="_search_and_match_operators">Search and match operators</h3>
<div class="paragraph">
<p>Additional operators exist expressed only in English, not C-like syntax:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>contains     Does the protocol, field or slice contain a value
matches, ~   Does the string match the given case-insensitive
             Perl-compatible regular expression</pre>
</div>
</div>
<div class="paragraph">
<p>The "contains" operator allows a filter to search for a sequence of
characters, expressed as a string, or bytes, expressed as a byte array.
The type of the left hand side of the "contains" operator must be comparable to
that of the right hand side after any implicit or explicit conversions.</p>
</div>
<div class="paragraph">
<p>For example, to search for a given HTTP
URL in a capture, the following filter can be used:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>http contains "https://www.wireshark.org"</pre>
</div>
</div>
<div class="paragraph">
<p>The "contains" operator cannot be used on atomic fields,
such as numbers or IP addresses.</p>
</div>
<div class="paragraph">
<p>The "matches" or "~" operator allows a filter to apply to a specified
Perl-compatible regular expression (PCRE2).  The regular expression must
be a double quoted string.  The left hand side of the "matches" operator
must be a string, which can be a non-stringlike field implicitly or
explicitly converted to a string.  Matches are case-insensitive by default.
For example, to search for a given WAP WSP User-Agent, you can write:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>wsp.header.user_agent matches "cldc"</pre>
</div>
</div>
<div class="paragraph">
<p>This would match "cldc", "CLDC", "cLdC" or any other combination of upper
and lower case letters.</p>
</div>
<div class="paragraph">
<p>You can force case sensitivity using</p>
</div>
<div class="literalblock">
<div class="content">
<pre>wsp.header.user_agent matches "(?-i)cldc"</pre>
</div>
</div>
<div class="paragraph">
<p>This is an example of PCRE2&#8217;s <strong>(?</strong>option<strong>)</strong> construct. <strong>(?-i)</strong> performs a
case-sensitive pattern match but other options can be specified as well. More
information can be found in the
pcre2pattern(3)|https://www.pcre.org/current/doc/html/pcre2pattern.html man page.</p>
</div>
</div>
<div class="sect2">
<h3 id="_functions">Functions</h3>
<div class="paragraph">
<p>The filter language has the following functions:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>upper(string-field) - converts a string field to uppercase
lower(string-field) - converts a string field to lowercase
len(field)          - returns the byte length of a string or bytes field
count(field)        - returns the number of field occurrences in a frame
string(field)       - converts a non-string field to string
max(f1,...,fn)      - return the maximum value
min(f1,...,fn)      - return the minimum value
abs(field)          - return the absolute value of numeric fields</pre>
</div>
</div>
<div class="paragraph">
<p>upper() and lower() are useful for performing case-insensitive string
comparisons. For example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>upper(ncp.nds_stream_name) contains "MACRO"
lower(mount.dump.hostname) == "angel"</pre>
</div>
</div>
<div class="paragraph">
<p>string() converts a field value to a string, suitable for use with operators like
"matches" or "contains". Integer fields are converted to their decimal representation.
It can be used with IP/Ethernet addresses (as well as others), but not with string or
byte fields. For example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>string(frame.number) matches "[13579]$"</pre>
</div>
</div>
<div class="paragraph">
<p>gives you all the odd packets.</p>
</div>
<div class="paragraph">
<p>max() and min() take any number of arguments and returns one value, respectively
the largest/smallest. The arguments must all have the same type.</p>
</div>
</div>
<div class="sect2">
<h3 id="_protocol_field_types">Protocol field types</h3>
<div class="paragraph">
<p>Each protocol field is typed. The types are:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ASN.1 object identifier, plain or relative
AX.25 address
Boolean
Byte sequence
Character string
Character, 1 byte
Date and time
Ethernet or other MAC address
EUI64 address
Fibre Channel WWN
Floating point, single or double precision
Frame number
Globally Unique Identifier
IEEE-11073 floating point, 16 or 32 bits
IPv4 address
IPv6 address
IPX network number
Label
OSI System-ID
Protocol
Signed integer, 1, 2, 3, 4, or 8 bytes
Time offset
Unsigned integer, 1, 2, 3, 4, or 8 bytes
VINES address</pre>
</div>
</div>
<div class="paragraph">
<p>An integer may be expressed in decimal, octal, hexadecimal or binary notation,
or as a C-style character constant.  The following seven display filters
are equivalent:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>frame.len &gt; 10
frame.len &gt; 012
frame.len &gt; 0xa
frame.len &gt; 0b1010
frame.len &gt; '\n'
frame.len &gt; '\x0a'
frame.len &gt; '\012'</pre>
</div>
</div>
<div class="paragraph">
<p>Boolean values are either true or false.  In a display filter expression
testing the value of a Boolean field, true is expressed as the word "True"
or "TRUE" (without quotes) or any non-zero number.  False is expressed as
"False" or "FALSE" or the number zero. For example, a token-ring packet&#8217;s
source route field is Boolean.  To find any source-routed packets, a display
filter would be any of the following:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>tr.sr == 1
tr.sr == True
tr.sr == TRUE</pre>
</div>
</div>
<div class="paragraph">
<p>Non source-routed packets can be found with:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>tr.sr == 0
tr.sr == False
tr.sr == FALSE</pre>
</div>
</div>
<div class="paragraph">
<p>Ethernet addresses and byte arrays are represented by hex
digits.  The hex digits may be separated by colons, periods, or hyphens:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>eth.dst eq ff:ff:ff:ff:ff:ff
aim.data == 0.1.0.d
fddi.src == aa-aa-aa-aa-aa-aa
echo.data == 7a</pre>
</div>
</div>
<div class="paragraph">
<p>IPv4 addresses can be represented in either dotted decimal notation or
by using the hostname:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ip.src == 192.168.1.1
ip.dst eq www.mit.edu</pre>
</div>
</div>
<div class="paragraph">
<p>IPv4 addresses can be compared with the same logical relations as numbers:
eq, ne, gt, ge, lt, and le.  The IPv4 address is stored in host order,
so you do not have to worry about the endianness of an IPv4 address
when using it in a display filter.</p>
</div>
<div class="paragraph">
<p>Classless Inter-Domain Routing (CIDR) notation can be used to test if an
IPv4 address is in a certain subnet.  For example, this display filter
will find all packets in the 129.111 network:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ip.addr == 129.111.0.0/16</pre>
</div>
</div>
<div class="paragraph">
<p>Remember, the number after the slash represents the number of bits used
to represent the network.  CIDR notation can also be used with
hostnames, as in this example of finding IP addresses on the same
network as 'sneezy' (requires that 'sneezy' resolve to an IP address for filter to be valid):</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ip.addr eq sneezy/24</pre>
</div>
</div>
<div class="paragraph">
<p>The CIDR notation can only be used on IP addresses or hostnames, not in
variable names.  So, a display filter like "ip.src/24 == ip.dst/24" is
not valid (yet).</p>
</div>
<div class="paragraph">
<p>Transaction and other IDs are often represented by unsigned 16 or 32 bit integers
and formatted as a hexadecimal string with "0x" prefix:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>(dhcp.id == 0xfe089c15) || (ip.id == 0x0373)</pre>
</div>
</div>
<div class="paragraph">
<p>Strings are enclosed in double quotes:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>http.request.method == "POST"</pre>
</div>
</div>
<div class="paragraph">
<p>Inside double quotes, you may use a backslash to embed a double quote
or an arbitrary byte represented in either octal or hexadecimal.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>browser.comment == "An embedded \" double-quote"</pre>
</div>
</div>
<div class="paragraph">
<p>Use of hexadecimal to look for "HEAD":</p>
</div>
<div class="literalblock">
<div class="content">
<pre>http.request.method == "\x48EAD"</pre>
</div>
</div>
<div class="paragraph">
<p>Use of octal to look for "HEAD":</p>
</div>
<div class="literalblock">
<div class="content">
<pre>http.request.method == "\110EAD"</pre>
</div>
</div>
<div class="paragraph">
<p>This means that you must escape backslashes with backslashes inside
double quotes.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>smb.path contains "\\\\SERVER\\SHARE"</pre>
</div>
</div>
<div class="paragraph">
<p>looks for \\SERVER\SHARE in "smb.path". This may be more conveniently written
as</p>
</div>
<div class="literalblock">
<div class="content">
<pre>smb.path contains r"\\SERVER\SHARE"</pre>
</div>
</div>
<div class="paragraph">
<p>String literals prefixed with 'r' are called "raw strings". Such strings treat
backslash as a literal character. Double quotes may still be escaped with
backslash but note that backslashes are always preserved in the result.</p>
</div>
<div class="paragraph">
<p>The following table lists all escape sequences supported with strings
and character constants:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>\'          single quote
\"          double quote
\\          backslash
\a          audible bell
\b          backspace
\f          form feed
\n          line feed
\r          carriage return
\t          horizontal tab
\v          vertical tab
\NNN        arbitrary octal value
\xNN        arbitrary hexadecimal value
\uNNNN      Unicode codepoint U+NNNN
\UNNNNNNNN  Unicode codepoint U+NNNNNNNN</pre>
</div>
</div>
<div class="paragraph">
<p>Date and time values can be given in ISO 8601 format or using a legacy
month-year-time format:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>"2020-07-04T12:34:56"
"Sep 26, 2004 23:18:04.954975"</pre>
</div>
</div>
<div class="paragraph">
<p>The 'T' separator in ISO 8601 can be omitted. ISO 8601 supports timezone
designators as UTC or an offset from UTC. Legacy formats can append the
value "UTC" at the end to specify time in Coordinated Universal Time.
Otherwise date and time values are interpreted as local time.</p>
</div>
</div>
<div class="sect2">
<h3 id="_the_slice_operator">The slice operator</h3>
<div class="paragraph">
<p>You can take a slice of a field if the field is a text string or a
byte array.
For example, you can filter on
the vendor portion of an ethernet address (the first three bytes) like
this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>eth.src[0:3] == 00:00:83</pre>
</div>
</div>
<div class="paragraph">
<p>Another example is:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>http.content_type[0:4] == "text"</pre>
</div>
</div>
<div class="paragraph">
<p>You can use the slice operator on a protocol name, too.
The "frame" protocol can be useful, encompassing all the data captured
by <strong>Wireshark</strong> or <strong>TShark</strong>.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>token[0:5] ne 0.0.0.1.1
llc[0] eq aa
frame[100-199] contains "wireshark"</pre>
</div>
</div>
<div class="paragraph">
<p>The following syntax governs slices:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>[i:j]    i = start_offset, j = length
[i-j]    i = start_offset, j = end_offset, inclusive.
[i]      i = start_offset, length = 1
[:j]     start_offset = 0, length = j
[i:]     start_offset = i, end_offset = end_of_field</pre>
</div>
</div>
<div class="paragraph">
<p>Offsets can be negative, in which case they indicate the
offset from the <strong>end</strong> of the field.  The last byte of the field is at offset
-1, the last but one byte is at offset -2, and so on.
Here&#8217;s how to check the last four bytes of a frame:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>frame[-4:4] == 0.1.2.3</pre>
</div>
</div>
<div class="paragraph">
<p>or</p>
</div>
<div class="literalblock">
<div class="content">
<pre>frame[-4:] == 0.1.2.3</pre>
</div>
</div>
<div class="paragraph">
<p>A slice can always be compared against either a string or a byte sequence.</p>
</div>
<div class="paragraph">
<p>Slices can be combined. You can concatenate them using the comma operator:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ftp[1,3-5,9:] == 01:03:04:05:09:0a:0b</pre>
</div>
</div>
<div class="paragraph">
<p>This concatenates offset 1, offsets 3-5, and offset 9 to the end of the ftp
data.</p>
</div>
</div>
<div class="sect2">
<h3 id="_the_layer_operator">The layer operator</h3>
<div class="paragraph">
<p>A field can be restricted to a certain layer in the protocol stack using the
layer operator (#), followed by a decimal number:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ip.addr#2 == 192.168.30.40</pre>
</div>
</div>
<div class="paragraph">
<p>matches only the inner (second) layer in the packet.
Layers use simple stacking semantics and protocol layers are counted sequentially starting from 1.
For example, in a packet that contains two IPv4 headers, the outer (first) source address can be matched with "ip.src#1" and the inner (second) source address can be matched with "ip.src#2".</p>
</div>
<div class="paragraph">
<p>For more complicated ranges the same syntax used with slices is valid:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>tcp.port#[2-4]</pre>
</div>
</div>
<div class="paragraph">
<p>means layers number 2, 3 or 4 inclusive. The hash symbol is required to
distinguish a layer range from a slice.</p>
</div>
</div>
<div class="sect2">
<h3 id="_the_membership_operator">The membership operator</h3>
<div class="paragraph">
<p>A field may be checked for matches against a set of values simply with the
membership operator. For instance, you may find traffic on common HTTP/HTTPS
ports with the following filter:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>tcp.port in {80,443,8080}</pre>
</div>
</div>
<div class="paragraph">
<p>as opposed to the more verbose:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>tcp.port == 80 or tcp.port == 443 or tcp.port == 8080</pre>
</div>
</div>
<div class="paragraph">
<p>To find HTTP requests using the HEAD or GET methods:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>http.request.method in {"HEAD", "GET"}</pre>
</div>
</div>
<div class="paragraph">
<p>The set of values can also contain ranges:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>tcp.port in {443, 4430..4434}
ip.addr in {10.0.0.5 .. 10.0.0.9, 192.168.1.1..192.168.1.9}
frame.time_delta in {10 .. 10.5}</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_implicit_type_conversions">Implicit type conversions</h3>
<div class="paragraph">
<p>Fields which are sequences of bytes, including protocols, are implicitly
converted to strings for comparisons against (double quoted) literal strings
and raw strings.</p>
</div>
<div class="paragraph">
<p>So, for instance, the following filters are equivalent:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>tcp.payload contains "GET"
tcp.payload contains 47.45.54</pre>
</div>
</div>
<div class="paragraph">
<p>As noted above, a slice can also be compared in either way:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>frame[60:2] gt 50.51
frame[60:2] gt "PQ"</pre>
</div>
</div>
<div class="paragraph">
<p>The inverse does not occur; stringlike fields are not implicitly converted to
byte arrays.  (Some operators allow stringlike fields to be compared with
unquoted literals, which are then treated as strings; this is deprecated in
general and specifically disallowed by the "matches" operator.
Literal strings should be double quoted for clarity.)</p>
</div>
<div class="paragraph">
<p>A hex integer that is 0xff or less (which means it fits inside one byte)
can be implicitly converted to a byte string.  This is not allowed for
hex integers greater than one byte, because then one would need to specify
the endianness of the multi-byte integer. Also, this is not allowed for
decimal or octal numbers, since they would be confused with the hex numbers
that make up byte string literals. Nevertheless, single-byte hex integers
can be convenient:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>frame[4] == 0xff
frame[1:4] contains 0x02</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_bitwise_operators">Bitwise operators</h3>
<div class="paragraph">
<p>It is also possible to define tests with bitwise operations. Currently the
following bitwise operator is supported:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>bitwise_and, &amp;	Bitwise AND</pre>
</div>
</div>
<div class="paragraph">
<p>The bitwise AND operation allows masking bits and testing to see if one or
more bits are set. Bitwise AND operates on integer protocol fields and slices.</p>
</div>
<div class="paragraph">
<p>When testing for TCP SYN packets, you can write:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>tcp.flags &amp; 0x02</pre>
</div>
</div>
<div class="paragraph">
<p>That expression will match all packets that contain a "tcp.flags" field
with the 0x02 bit, i.e. the SYN bit, set.</p>
</div>
<div class="paragraph">
<p>To match locally administered unicast ethernet addresses you can use:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>eth.addr[0] &amp; 0x0f == 2</pre>
</div>
</div>
<div class="paragraph">
<p>When using slices, the bit mask must be specified as a byte string, and it must
have the same number of bytes as the slice itself, as in:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ip[42:2] &amp; 40:ff</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_arithmetic_operators">Arithmetic operators</h3>
<div class="paragraph">
<p>Arithmetic expressions are supported with the usual operators:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>+   Addition
-   Subtraction
*   Multiplication
/   Division
%   Modulo (integer remainder)</pre>
</div>
</div>
<div class="paragraph">
<p>For example it is possible to filter for UDP destination ports greater or
equal by one to the source port with the expression:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>udp.dstport &gt;= udp.srcport + 1</pre>
</div>
</div>
<div class="paragraph">
<p>It is possible to group arithmetic expressions using curly brackets (parenthesis
will not work for this):</p>
</div>
<div class="literalblock">
<div class="content">
<pre>tcp.dstport &gt;= 4 * {tcp.srcport + 3}</pre>
</div>
</div>
<div class="paragraph">
<p>Do not confuse this usage of curly brackets with set membership.</p>
</div>
<div class="paragraph">
<p>An unfortunate quirk in the filter syntax is that the subtraction operator
must be preceded by a space character, so "A-B" must be written as "A -B"
or "A - B".</p>
</div>
</div>
<div class="sect2">
<h3 id="_protocol_field_references">Protocol field references</h3>
<div class="paragraph">
<p>A variable using a sigil with the form ${some.proto.field} is called a field
reference. A field reference is a field value read from the currently
selected frame in the GUI. This is useful to build dynamic filters such as,
frames since the last five minutes to the selected frame:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>frame.time_relative &gt;= ${frame.time_relative} - 300</pre>
</div>
</div>
<div class="paragraph">
<p>Field references share a similar notation to macros but are distinct
syntactical elements in the filter language.</p>
</div>
</div>
<div class="sect2">
<h3 id="_logical_expressions">Logical expressions</h3>
<div class="paragraph">
<p>Tests can be combined using logical expressions.
These too are expressible in C-like syntax or with English-like
abbreviations. The following table lists the logical operators from
highest to lowest precedence:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>not, !    Logical NOT   (right-associative)
and, &amp;&amp;   Logical AND   (left-associative)
or,  ||   Logical OR    (left-associative)</pre>
</div>
</div>
<div class="paragraph">
<p>The evaluation is always performed left to right. Expressions can be grouped
by parentheses as well. The expression "A and B or not C or D and not E or F"
is read:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>(A and B) or (not C) or (D and (not E)) or F</pre>
</div>
</div>
<div class="paragraph">
<p>It&#8217;s usually better to be explicit about grouping using parenthesis.
The following are all valid display filter expressions:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>tcp.port == 80 and ip.src == 192.168.2.1
not llc
http and frame[100-199] contains "wireshark"
(ipx.src.net == 0xbad &amp;&amp; ipx.src.node == 0.0.0.0.0.1) || ip</pre>
</div>
</div>
<div class="paragraph">
<p>Remember that whenever a protocol or field name occurs in an expression, the
"exists" operator is implicitly called. The "exists" operator has the highest
priority. This means that the first filter expression must be read as "show me
the packets for which tcp.port exists and equals 80, and ip.src exists and
equals 192.168.2.1". The second filter expression means "show me the packets
where not exists llc", or in other words "where llc does not exist" and hence
will match all packets that do not contain the llc protocol.
The third filter expression includes the constraint that offset 199 in the
frame exists, in other words the length of the frame is at least 200.</p>
</div>
<div class="paragraph">
<p>Each comparison has an implicit exists test for any field value. Care must
be taken when using the display filter to remove noise from
the packet trace. If, for example, you want to filter out all IP
multicast packets to address 224.1.2.3, then using:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ip.dst ne 224.1.2.3</pre>
</div>
</div>
<div class="paragraph">
<p>may be too restrictive. This is the same as writing:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ip.dst and ip.dst ne 224.1.2.3</pre>
</div>
</div>
<div class="paragraph">
<p>The filter selects only frames that have the "ip.dst" field. Any
other frames, including all non-IP packets, will not be displayed. To
display the non-IP packets as well, you can use one of the following
two expressions:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>not ip.dst or ip.dst ne 224.1.2.3
not ip.dst eq 224.1.2.3</pre>
</div>
</div>
<div class="paragraph">
<p>The first filter uses "not ip.dst" to include all non-IP packets and then
lets "ip.dst ne 224.1.2.3" filter out the unwanted IP packets. The
second filter also negates the implicit existance test and so is
a shorter way to write the first.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_filter_field_reference">FILTER FIELD REFERENCE</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The entire list of display filters is too large to list here. You can
can find references and examples at the following locations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The online Display Filter Reference: <a href="https://www.wireshark.org/docs/dfref/" class="bare">https://www.wireshark.org/docs/dfref/</a></p>
</li>
<li>
<p><em>View:Internals:Supported Protocols</em> in Wireshark</p>
</li>
<li>
<p><code>tshark -G fields</code> on the command line</p>
</li>
<li>
<p>The Wireshark wiki: <a href="https://gitlab.com/wireshark/wireshark/-/wikis/DisplayFilters" class="bare">https://gitlab.com/wireshark/wireshark/-/wikis/DisplayFilters</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_notes">NOTES</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <strong><a href="wireshark-filter.html">wireshark-filter</a>(4)</strong> manpage is part of the <strong>Wireshark</strong> distribution.
The latest version of <strong>Wireshark</strong> can be found at
<a href="https://www.wireshark.org" class="bare">https://www.wireshark.org</a>.</p>
</div>
<div class="paragraph">
<p>Regular expressions in the "matches" operator are provided by the PCRE2 library.
See <a href="https://www.pcre.org/" class="bare">https://www.pcre.org/</a> for more information.</p>
</div>
<div class="paragraph">
<p>This manpage does not describe the capture filter syntax, which is
different. See the manual page of <a href="https://www.tcpdump.org/manpages/pcap-filter.7.html">pcap-filter</a>(7) or, if that doesn&#8217;t exist,
<a href="https://www.tcpdump.org/manpages/tcpdump.1.html">tcpdump</a>(8), or, if that doesn&#8217;t exist, <a href="https://gitlab.com/wireshark/wireshark/-/wikis/CaptureFilters" class="bare">https://gitlab.com/wireshark/wireshark/-/wikis/CaptureFilters</a>
for a description of capture filters.</p>
</div>
<div class="paragraph">
<p>Display Filters are also described in the User&#8217;s Guide:
<a href="https://www.wireshark.org/docs/wsug_html_chunked/ChWorkBuildDisplayFilterSection.html" class="bare">https://www.wireshark.org/docs/wsug_html_chunked/ChWorkBuildDisplayFilterSection.html</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_see_also">SEE ALSO</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="wireshark.html">wireshark</a>(1), <a href="tshark.html">tshark</a>(1), <a href="editcap.html">editcap</a>(1), <a href="https://www.tcpdump.org/manpages/pcap.3pcap.html">pcap</a>(3), <a href="https://www.tcpdump.org/manpages/pcap-filter.7.html">pcap-filter</a>(7) or <a href="https://www.tcpdump.org/manpages/tcpdump.1.html">tcpdump</a>(8) if it
doesn&#8217;t exist.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_authors">AUTHORS</h2>
<div class="sectionbody">
<div class="paragraph">
<p>See the list of authors in the <strong>Wireshark</strong> man page for a list of authors of
that code.</p>
</div>
</div>
</div>
</div>
</body>
</html>