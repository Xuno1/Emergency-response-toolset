<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="/en/github.css" type="text/css" />
</head>
<body>
<h1 id="libclamav">LibClamAV</h1>
<p>Libclamav provides an easy and effective way to add a virus protection into your software. The library is thread-safe and transparently recognizes and scans within archives, mail files, MS Office document files, executables and other special formats.</p>
<h2 id="license">License</h2>
<p>Libclamav is licensed under the GNU GPL v2 license. This means you are <strong>not allowed</strong> to link commercial, closed-source software against it. All software using libclamav must be GPL compliant.</p>
<h2 id="supported-formats-and-features">Supported formats and features</h2>
<h3 id="executables">Executables</h3>
<p>The library has a built-in support for 32- and 64-bit Portable Executable, ELF and Mach-O files. Additionally, it can handle PE files compressed or obfuscated with the following tools:</p>
<ul>
<li>Aspack (2.12)</li>
<li>UPX (all versions)</li>
<li>FSG (1.3, 1.31, 1.33, 2.0)</li>
<li>Petite (2.x)</li>
<li>PeSpin (1.1)</li>
<li>NsPack</li>
<li>wwpack32 (1.20)</li>
<li>MEW</li>
<li>Upack</li>
<li>Y0da Cryptor (1.3)</li>
</ul>
<h3 id="mail-files">Mail files</h3>
<p>Libclamav can handle almost every mail file format including TNEF (winmail.dat) attachments.</p>
<h3 id="archives-and-compressed-files">Archives and compressed files</h3>
<p>The following archive and compression formats are supported by internal handlers:</p>
<ul>
<li>Zip (+ SFX)</li>
<li>RAR (+ SFX)</li>
<li>7Zip</li>
<li>Tar</li>
<li>CPIO</li>
<li>Gzip</li>
<li>Bzip2</li>
<li>DMG</li>
<li>IMG</li>
<li>ISO 9660</li>
<li>PKG</li>
<li>HFS+ partition</li>
<li>HFSX partition</li>
<li>APM disk image</li>
<li>GPT disk image</li>
<li>MBR disk image</li>
<li>XAR</li>
<li>XZ</li>
<li>MS OLE2</li>
<li>MS Cabinet Files (+ SFX)</li>
<li>MS CHM (Compiled HTML)</li>
<li>MS SZDD compression format</li>
<li>BinHex</li>
<li>SIS (SymbianOS packages)</li>
<li>AutoIt</li>
<li>NSIS</li>
<li>InstallShield</li>
</ul>
<h3 id="documents">Documents</h3>
<p>The most popular file formats are supported:</p>
<ul>
<li>MS Office and MacOffice files</li>
<li>RTF</li>
<li>PDF</li>
<li>HTML</li>
</ul>
<p>In the case of Office, RTF and PDF files, libclamav will only extract the embedded objects and will not decode the text data itself. The text decoding and normalization is only performed for HTML files.</p>
<h3 id="data-loss-prevention">Data Loss Prevention</h3>
<p>Libclamav includes a DLP module which can detect the following credit card issuers: AMEX, VISA, MasterCard, Discover, Diner’s Club, and JCB and U.S. social security numbers inside text files.</p>
<p>Future versions of Libclamav may include additional features to detect other credit cards and other forms of PII (Personally Identifiable Information) which may be transmitted without the benefit of being encrypted.</p>
<h3 id="others">Others</h3>
<p>Libclamav can handle various obfuscators, encoders, files vulnerable to security risks such as:</p>
<ul>
<li>JPEG (exploit detection)</li>
<li>RIFF (exploit detection)</li>
<li>uuencode</li>
<li>ScrEnc obfuscation</li>
<li>CryptFF</li>
</ul>
<h2 id="api">API</h2>
<h3 id="header-file">Header file</h3>
<p>Every program using libclamav must include the header file <code>clamav.h</code>:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">    <span class="pp">#include </span><span class="im">&lt;clamav.h&gt;</span></code></pre></div>
<h3 id="initialization">Initialization</h3>
<p>Before using libclamav, you should call <code>cl_init()</code> to initialize it. <code>CL_INIT_DEFAULT</code> is a macro that can be passed to <code>cl_init()</code> representing the default initialization settings. When it’s done, you’re ready to create a new scan engine by calling <code>cl_engine_new()</code>. To free resources allocated by the engine use <code>cl_engine_free()</code>. Function prototypes:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">    <span class="dt">int</span> cl_init(<span class="dt">unsigned</span> <span class="dt">int</span> options);
    <span class="kw">struct</span> cl_engine *cl_engine_new(<span class="dt">void</span>);
    <span class="dt">int</span> cl_engine_free(<span class="kw">struct</span> cl_engine *engine);</code></pre></div>
<p><code>cl_init()</code> and <code>cl_engine_free()</code> return <code>CL_SUCCESS</code> on success or another code on error. <code>cl_engine_new()</code> return a pointer or NULL if there’s not enough memory to allocate a new engine structure.</p>
<h3 id="database-loading">Database loading</h3>
<p>The following set of functions provides an interface for loading the virus database:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">    <span class="dt">const</span> <span class="dt">char</span> *cl_retdbdir(<span class="dt">void</span>);

    <span class="dt">int</span> cl_load(<span class="dt">const</span> <span class="dt">char</span> *path, <span class="kw">struct</span> cl_engine *engine,
            <span class="dt">unsigned</span> <span class="dt">int</span> *signo, <span class="dt">unsigned</span> <span class="dt">int</span> options);</code></pre></div>
<p><code>cl_retdbdir()</code> returns the default (hardcoded) path to the directory with ClamAV databases. <code>cl_load()</code> loads a single database file or all databases from a given directory (when <code>path</code> points to a directory). The second argument is used for passing in the pointer to the engine that should be previously allocated with <code>cl_engine_new()</code>. A number of loaded signatures will be <strong>added</strong> to <code>signo</code>. The last argument can pass the following flags:</p>
<ul>
<li><strong>CL_DB_STDOPT</strong><br />
This is an alias for a recommended set of scan options.</li>
<li><strong>CL_DB_PHISHING</strong><br />
Load phishing signatures.</li>
<li><strong>CL_DB_PHISHING_URLS</strong><br />
Initialize the phishing detection module and load .wdb and .pdb<br />
files.</li>
<li><strong>CL_DB_PUA</strong><br />
Load signatures for Potentially Unwanted Applications.</li>
<li><strong>CL_DB_OFFICIAL_ONLY</strong><br />
Only load official signatures from digitally signed databases.</li>
<li><strong>CL_DB_BYTECODE</strong><br />
Load bytecode.</li>
</ul>
<p><code>cl_load()</code> returns <code>CL_SUCCESS</code> on success and another code on failure.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">        ...
        <span class="kw">struct</span> cl_engine *engine;
        <span class="dt">unsigned</span> <span class="dt">int</span> sigs = <span class="dv">0</span>;
        <span class="dt">int</span> ret;

    <span class="cf">if</span>((ret = cl_init(CL_INIT_DEFAULT)) != CL_SUCCESS) {
        printf(<span class="st">&quot;cl_init() error: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, cl_strerror(ret));
        <span class="cf">return</span> <span class="dv">1</span>;
    }

    <span class="cf">if</span>(!(engine = cl_engine_new())) {
        printf(<span class="st">&quot;Can&#39;t create new engine</span><span class="sc">\n</span><span class="st">&quot;</span>);
        <span class="cf">return</span> <span class="dv">1</span>;
    }

    ret = cl_load(cl_retdbdir(), engine, &amp;sigs, CL_DB_STDOPT);</code></pre></div>
<h3 id="error-handling">Error handling</h3>
<p>Use <code>cl_strerror()</code> to convert error codes into human readable messages. The function returns a statically allocated string:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">    <span class="cf">if</span>(ret != CL_SUCCESS) {
        printf(<span class="st">&quot;cl_load() error: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, cl_strerror(ret));
        cl_engine_free(engine);
        <span class="cf">return</span> <span class="dv">1</span>;
    }</code></pre></div>
<h3 id="engine-structure">Engine structure</h3>
<p>When all required databases are loaded you should prepare the detection engine by calling <code>cl_engine_compile()</code>. In case of failure you should still free the memory allocated to the engine with <code>cl_engine_free()</code>:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">    <span class="dt">int</span> cl_engine_compile(<span class="kw">struct</span> cl_engine *engine);</code></pre></div>
<p>In our example:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">    <span class="cf">if</span>((ret = cl_engine_compile(engine)) != CL_SUCCESS) {
        printf(<span class="st">&quot;cl_engine_compile() error: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, cl_strerror(ret));
        cl_engine_free(engine);
        <span class="cf">return</span> <span class="dv">1</span>;
    }</code></pre></div>
<h3 id="limits">Limits</h3>
<p>When you create a new engine with <code>cl_engine_new()</code>, it will have all internal settings set to default values as recommended by the ClamAV authors. It’s possible to check and modify the values (numerical and strings) using the following set of functions:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> cl_engine_set_num(<span class="kw">struct</span> cl_engine *engine,
  <span class="kw">enum</span> cl_engine_field field, <span class="dt">long</span> <span class="dt">long</span> num);

<span class="dt">long</span> <span class="dt">long</span> cl_engine_get_num(<span class="dt">const</span> <span class="kw">struct</span> cl_engine *engine,
  <span class="kw">enum</span> cl_engine_field field, <span class="dt">int</span> *err);

<span class="dt">int</span> cl_engine_set_str(<span class="kw">struct</span> cl_engine *engine,
  <span class="kw">enum</span> cl_engine_field field, <span class="dt">const</span> <span class="dt">char</span> *str);

<span class="dt">const</span> <span class="dt">char</span> *cl_engine_get_str(<span class="dt">const</span> <span class="kw">struct</span> cl_engine *engine,
  <span class="kw">enum</span> cl_engine_field field, <span class="dt">int</span> *err);</code></pre></div>
<p>Please don’t modify the default values unless you know what you’re doing. Refer to the ClamAV sources (clamscan, clamd) for examples.</p>
<h3 id="database-checks">Database checks</h3>
<p>It’s very important to keep the internal instance of the database up to date. You can watch database changes with the <code>cl_stat..()</code> family of functions.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">    <span class="dt">int</span> cl_statinidir(<span class="dt">const</span> <span class="dt">char</span> *dirname, <span class="kw">struct</span> cl_stat *dbstat);
    <span class="dt">int</span> cl_statchkdir(<span class="dt">const</span> <span class="kw">struct</span> cl_stat *dbstat);
    <span class="dt">int</span> cl_statfree(<span class="kw">struct</span> cl_stat *dbstat);</code></pre></div>
<p>Initialization:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">        ...
        <span class="kw">struct</span> cl_stat dbstat;

    memset(&amp;dbstat, <span class="dv">0</span>, <span class="kw">sizeof</span>(<span class="kw">struct</span> cl_stat));
    cl_statinidir(dbdir, &amp;dbstat);</code></pre></div>
<p>To check for a change you just need to call <code>cl_statchkdir</code> and check its return value (0 - no change, 1 - some change occurred). Remember to reset the <code>cl_stat</code> structure after reloading the database.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">    <span class="cf">if</span>(cl_statchkdir(&amp;dbstat) == <span class="dv">1</span>) {
        reload_database...;
        cl_statfree(&amp;dbstat);
        cl_statinidir(cl_retdbdir(), &amp;dbstat);
    }</code></pre></div>
<p>Libclamav (\ge0.96) includes and additional call to check the number of signatures that can be loaded from a given directory:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">    <span class="dt">int</span> cl_countsigs(<span class="dt">const</span> <span class="dt">char</span> *path, <span class="dt">unsigned</span> <span class="dt">int</span> countoptions,
        <span class="dt">unsigned</span> <span class="dt">int</span> *sigs);</code></pre></div>
<p>The first argument points to the database directory, the second one specifies what signatures should be counted: <code>CL_COUNTSIGS_OFFICIAL</code> (official signatures), <code>CL_COUNTSIGS_UNOFFICIAL</code> (third party signatures), <code>CL_COUNTSIGS_ALL</code> (all signatures). The last argument points to the counter to which the number of detected signatures will be added (therefore the counter should be initially set to 0). The call returns <code>CL_SUCCESS</code> or an error code.</p>
<h3 id="data-scan-functions">Data scan functions</h3>
<p>It’s possible to scan a file or descriptor using:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">    <span class="dt">int</span> cl_scanfile(
        <span class="dt">const</span> <span class="dt">char</span> *filename,
        <span class="dt">const</span> <span class="dt">char</span> **virname,
        <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">int</span> *scanned,
        <span class="dt">const</span> <span class="kw">struct</span> cl_engine *engine,
        <span class="kw">struct</span> cl_scan_options *options);

    <span class="dt">int</span> cl_scandesc(
        <span class="dt">int</span> desc,
        <span class="dt">const</span> <span class="dt">char</span> *filename,
        <span class="dt">const</span> <span class="dt">char</span> **virname,
        <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">int</span> *scanned,
        <span class="dt">const</span> <span class="kw">struct</span> cl_engine *engine,
        <span class="kw">struct</span> cl_scan_options *options);</code></pre></div>
<p>Both functions will store a virus name under the pointer <code>virname</code>, the virus name is part of the engine structure and must not be released directly. If the third argument (<code>scanned</code>) is not NULL, the functions will increase its value with the size of scanned data (in <code>CL_COUNT_PRECISION</code> units). The last argument (<code>options</code>) requires a pointer to a data structure that specifies the scan options. The data structure should be <code>memset()</code> Each variable in the structure is a bit-flag field. The structure definition is:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">    <span class="kw">struct</span> cl_scan_options {
        <span class="dt">uint32_t</span> general;
        <span class="dt">uint32_t</span> parse;
        <span class="dt">uint32_t</span> alert;
        <span class="dt">uint32_t</span> heuristic_alert;
        <span class="dt">uint32_t</span> mail;
        <span class="dt">uint32_t</span> dev;
    };</code></pre></div>
<p>Supported flags for each of the fields are as follows:</p>
<p><code>general</code> - General scanning options.</p>
<ul>
<li><strong>CL_SCAN_GENERAL_ALLMATCHES</strong><br />
Scan in all-match mode</li>
<li><strong>CL_SCAN_GENERAL_COLLECT_METADATA</strong><br />
Collect metadata (--gen-json)</li>
<li><strong>CL_SCAN_GENERAL_HEURISTICS</strong><br />
Option to enable heuristic alerts. Required for any of the heuristic alerting options to work.</li>
</ul>
<p><code>parse</code> - Options to enable/disable specific parsing capabilities. Generally you will want to enable all parsers. The easiest way to do this is to set the parse flags to ~0.</p>
<ul>
<li><strong>CL_SCAN_PARSE_ARCHIVE</strong><br />
This flag enables transparent scanning of various archive formats.</li>
<li><strong>CL_SCAN_PARSE_ELF</strong><br />
Enable support for ELF files.</li>
<li><strong>CL_SCAN_PARSE_PDF</strong><br />
Enables scanning within PDF files.</li>
<li><strong>CL_SCAN_PARSE_SWF</strong><br />
Enables scanning within SWF files, notably compressed SWF.</li>
<li><strong>CL_SCAN_PARSE_HWP</strong><br />
Enables scanning of Hangul Word Processor (HWP) files.</li>
<li><strong>CL_SCAN_PARSE_XMLDOCS</strong><br />
Enables scanning of XML-formatted documents (e.g. Word, Excel, Powerpoint, HWP).</li>
<li><strong>CL_SCAN_PARSE_MAIL</strong><br />
Enable support for mail files.</li>
<li><strong>CL_SCAN_PARSE_OLE2</strong><br />
Enables support for OLE2 containers (used by MS Office and .msi files).</li>
<li><strong>CL_SCAN_PARSE_HTML</strong><br />
This flag enables HTML normalisation (including ScrEnc decryption).</li>
<li><strong>CL_SCAN_PARSE_PE</strong><br />
This flag enables deep scanning of Portable Executable files and allows libclamav to unpack executables compressed with run-time unpackers.</li>
</ul>
<p><code>heuristic</code> - Options to enable specific heuristic alerts</p>
<ul>
<li><strong>CL_SCAN_GENERAL_HEURISTIC_PRECEDENCE</strong><br />
Allow heuristic match to take precedence. When enabled, if a heuristic scan (such as phishingScan) detects a possible virus/phish it will stop scan immediately. Recommended, saves CPU scan-time. When <em>disabled</em>, virus/phish detected by heuristic scans will be reported only at the end of a scan. If an archive contains both a heuristically detected virus/phishing, and a real malware, the real malware will be reported.</li>
<li><strong>CL_SCAN_HEURISTIC_ENCRYPTED_ARCHIVE</strong><br />
With this flag the library will mark encrypted archives as viruses (encrypted .zip, .7zip, .rar).</li>
<li><strong>CL_SCAN_HEURISTIC_ENCRYPTED_DOC</strong><br />
With this flag the library will mark encrypted docuemnts as viruses (encrypted .pdf).</li>
<li><strong>CL_SCAN_HEURISTIC_BROKEN</strong><br />
libclamav will try to detect broken executables and mark them as Broken.Executable.</li>
<li><strong>CL_SCAN_HEURISTIC_EXCEEDS_MAX</strong><br />
Alert when the scan of any file exceeds maximums such as max filesize, max scansize, max recursion level.</li>
<li><strong>CL_SCAN_HEURISTIC_PHISHING_SSL_MISMATCH</strong><br />
Heuristic for phishing module: alert on SSL mismatches in URLs.</li>
<li><strong>CL_SCAN_HEURISTIC_PHISHING_CLOAK</strong><br />
Heuristic for phishing module: alert on cloaked URLs.</li>
<li><strong>CL_SCAN_HEURISTIC_MACROS</strong><br />
OLE2 containers, which contain VBA macros will be marked infected (Heuristics.OLE2.ContainsMacros).</li>
<li><strong>CL_SCAN_HEURISTIC_PARTITION_INTXN</strong><br />
alert if partition table size doesn't make sense</li>
<li><strong>CL_SCAN_HEURISTIC_STRUCTURED</strong><br />
Enable the data loss prevention (DLP) module which scans for credit card and SSN numbers. i.e. alert when detecting personal information</li>
<li><strong>CL_SCAN_HEURISTIC_STRUCTURED_SSN_NORMAL</strong><br />
Search for [and alert when detecting] SSNs formatted as xx-yy-zzzz.</li>
<li><strong>CL_SCAN_HEURISTIC_STRUCTURED_SSN_STRIPPED</strong><br />
Search for [and alert when detecting] SSNs formatted as xxyyzzzz.</li>
</ul>
<p><code>mail</code> - Options to enable specific mail parsing features</p>
<ul>
<li><strong>CL_SCAN_MAIL_PARTIAL_MESSAGE</strong><br />
Scan RFC1341 messages split over many emails. You will need to periodically clean up <code>$TemporaryDirectory/clamav-partial</code> directory.</li>
</ul>
<p><code>dev</code> - Options designed for use by ClamAV developers</p>
<ul>
<li><strong>CL_SCAN_DEV_COLLECT_SHA</strong><br />
Enables hash output in sha-collect builds - for internal use only</li>
<li><strong>CL_SCAN_DEV_COLLECT_PERFORMANCE_INFO</strong><br />
Collect performance timings</li>
</ul>
<p>All functions return <code>CL_CLEAN</code> when the file seems clean, <code>CL_VIRUS</code> when a virus is detected and another value on failure.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">        ...
        <span class="dt">const</span> <span class="dt">char</span> *virname;

    <span class="cf">if</span>((ret = cl_scanfile(<span class="st">&quot;/tmp/test.exe&quot;</span>, &amp;virname, NULL, engine,
    &amp;options)) == CL_VIRUS) {
        printf(<span class="st">&quot;Virus detected: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, virname);
    } <span class="cf">else</span> {
        printf(<span class="st">&quot;No virus detected.</span><span class="sc">\n</span><span class="st">&quot;</span>);
        <span class="cf">if</span>(ret != CL_CLEAN)
            printf(<span class="st">&quot;Error: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, cl_strerror(ret));
    }</code></pre></div>
<h3 id="memory">Memory</h3>
<p>Because the engine structure occupies a few megabytes of system memory, you should release it with <code>cl_engine_free()</code> if you no longer need to scan files.</p>
<h3 id="forking-daemons">Forking daemons</h3>
<p>If you’re using libclamav with a forking daemon you should call <code>srand()</code> inside a forked child before making any calls to the libclamav functions. This will avoid possible collisions with temporary filenames created by other processes of the daemon. This procedure is not required for multi-threaded daemons.</p>
<h3 id="clamav-config">clamav-config</h3>
<p>Use <code>clamav-config</code> to check compilation information for libclamav.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">    $ <span class="ex">clamav-config</span> --libs
    <span class="ex">-L/usr/local/lib</span> -lz -lbz2 -lgmp -lpthread
    $ <span class="ex">clamav-config</span> --cflags
    <span class="ex">-I/usr/local/include</span> -g -O2</code></pre></div>
<h3 id="example">Example</h3>
<p>You will find an example scanner application in the clamav source package (/example). Provided you have ClamAV already installed, execute the following to compile it:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">    <span class="fu">gcc</span> -Wall ex1.c -o ex1 -lclamav</code></pre></div>
<h2 id="cvd-format">CVD format</h2>
<p>CVD (ClamAV Virus Database) is a digitally signed tarball containing one or more databases. The header is a 512-bytes long string with colon separated fields:</p>
<div class="sourceCode"><pre class="sourceCode ini"><code class="sourceCode ini"><span class="dt">ClamAV-VDB:build time:version:number of signatures:functionality</span>
<span class="dt">level required:MD5 checksum:digital signature:builder name:build time (sec)</span></code></pre></div>
<p><code>sigtool --info</code> displays detailed information on CVD files:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="ex">sigtool</span> -i daily.cvd
<span class="ex">File</span>: daily.cvd
<span class="ex">Build</span> time: 10 Mar 2008 10:45 +0000
<span class="ex">Version</span>: 6191
<span class="ex">Signatures</span>: 59084
<span class="ex">Functionality</span> level: 26
<span class="ex">Builder</span>: ccordes
<span class="ex">MD5</span>: 6e6e29dae36b4b7315932c921e568330
<span class="ex">Digital</span> signature: zz9irc9irupR3z7yX6J+OR6XdFPUat4HIM9ERn3kAcOWpcMFxq
<span class="ex">Fs4toG5WJsHda0Jj92IUusZ7wAgYjpai1Nr+jFfXHsJxv0dBkS5/XWMntj0T1ctNgqmiF</span>
<span class="ex">+RLU6V0VeTl4Oej3Aya0cVpd9K4XXevEO2eTTvzWNCAq0ZzWNdjc</span>
<span class="ex">Verification</span> OK.</code></pre></div>
<h2 id="graphics">Graphics</h2>
<p>The current ClamAV logo was created by Alicia Willet, Talos.</p>
<h2 id="openantivirus">OpenAntiVirus</h2>
<p>Our database includes the virus database (about 7000 signatures) from OpenAntiVirus (<a href="http://OpenAntiVirus.org" class="uri">http://OpenAntiVirus.org</a>).</p>
<ol>
<li><p>Subscribers are not allowed to post to the mailing list</p></li>
<li><p>For Windows instructions please see win32/README in the main source code directory.</p></li>
<li><p>See section <a href="#unit-testing">3.7</a> on how to run the unit tests</p></li>
<li><p>if not available ClamAV will fall back to an interpreter</p></li>
<li><p>Note that several versions of GCC have bugs when compiling LLVM, see <a href="http://llvm.org/docs/GettingStarted.html#brokengcc" class="uri">http://llvm.org/docs/GettingStarted.html#brokengcc</a> for a full list.</p></li>
<li><p>The configure script in ClamAV automatically enables the unit tests, if it finds the check framework, however it doesn’t consider it a fatal error if unit tests cannot be enabled.</p></li>
<li><p>To get more info on clamscan options run ’man clamscan’</p></li>
<li><p>man 5 clamd.conf</p></li>
<li><p>Remember to initialize the virus counter variable with 0.</p></li>
</ol>
</body>
</html>
